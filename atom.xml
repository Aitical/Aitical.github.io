<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aitical的个人小站</title>
  
  <subtitle>一直在走,走灰多少太阳</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-07T11:57:55.339Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>吴刚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Centos安装python3与pip3</title>
    <link href="http://yoursite.com/2018/07/07/Centos%E5%AE%89%E8%A3%85python3%E4%B8%8Epip3/"/>
    <id>http://yoursite.com/2018/07/07/Centos安装python3与pip3/</id>
    <published>2018-07-07T11:51:07.000Z</published>
    <updated>2018-07-07T11:57:55.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装必要依赖"><a href="#安装必要依赖" class="headerlink" title="安装必要依赖"></a>安装必要依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install gcc  </span><br><span class="line">sudo yum -y install zlib zlib-devel</span><br><span class="line">sudo yum -y install libffi-devel </span><br><span class="line">sudo yum -y install openssl-devel ncurses-devel</span><br></pre></td></tr></table></figure><h3 id="下载python3-7"><a href="#下载python3-7" class="headerlink" title="下载python3.7"></a>下载python3.7</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</span><br></pre></td></tr></table></figure><h3 id="创建安装目录"><a href="#创建安装目录" class="headerlink" title="创建安装目录"></a>创建安装目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/local/python3</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Python-3.7.0.tgz</span><br><span class="line"></span><br><span class="line">cd Python-3.7.0/</span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/python3 --enable-optimizations</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>加了<code>--enable-optimizations</code>之后时间比较久,但是用于提升python的性能</p><h3 id="创建python3链接"><a href="#创建python3链接" class="headerlink" title="创建python3链接"></a>创建python3链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/python3.7 /usr/bin/python3</span><br></pre></td></tr></table></figure><h3 id="创建pip3链接"><a href="#创建pip3链接" class="headerlink" title="创建pip3链接"></a>创建pip3链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装必要依赖&quot;&gt;&lt;a href=&quot;#安装必要依赖&quot; class=&quot;headerlink&quot; title=&quot;安装必要依赖&quot;&gt;&lt;/a&gt;安装必要依赖&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>PCA(主成成分分析)学习笔记</title>
    <link href="http://yoursite.com/2018/05/10/PCA-%E4%B8%BB%E6%88%90%E6%88%90%E5%88%86%E5%88%86%E6%9E%90-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/05/10/PCA-主成成分分析-学习笔记/</id>
    <published>2018-05-10T08:23:46.000Z</published>
    <updated>2018-05-11T02:27:34.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>做机器学习训练时会遇到这样一个:原始数据特征的维度特别高,不利于模型的训练.这时候我们需要对原始数据的特征向量进行降维处理，然后将降维后的数据输入到模型中进行训练,得出最终的训练模型.<br>比如:</p><blockquote><p>比如拿到一个汽车的样本，里面既有以“千米/每小时”度量的最大速度特征，也有“英里/小时”的最大速度特征，显然这两个特征有一个多余。</p></blockquote><p>PCA就是用来对高维度数据进行降维,但是降维或多或少地会带来一定的信息损失,所以在实现PCA的时候要用到一定的策略减小损失–最大方差投影</p><h2 id="PCA的实现"><a href="#PCA的实现" class="headerlink" title="PCA的实现"></a>PCA的实现</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>设有 m 条 n 维数据。<br>1）将原始数据按列组成 n 行 m 列矩阵 $X$<br>2）将$X$的每一行(代表一个属性字段)进行零均值化,即减去这一行的均值<br>3）求出协方差矩阵$C=\frac{1}{m}X\cdot X^{T}$<br>4）求出协方差矩阵的特征值及对应的特征向量<br>5）将特征向量按对应特征值大小从上到下按行排列成矩阵，取前 k 行组成矩阵 $P$<br>6）$Y = P \cdot X$即为降维到 k 维后的数据</p><h3 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h3><p>这部分是为了便于理解$PCA$</p><h4 id="数据的向量表示"><a href="#数据的向量表示" class="headerlink" title="数据的向量表示"></a>数据的向量表示</h4><p>一般情况下,数据都是一条一条记录的形式展现,比如</p><blockquote><p>淘宝店2012年全年的流量及交易情况中的一条记录如下</p><p>(日期, 浏览量, 访客数, 下单数, 成交数, 成交金额)</p></blockquote><p>由于日期是标记量,这里只关注后面的几个度量值$(500,240,25,13,2312.15)$这样就是一条数据的向量表示,习惯上我们把输入数据表示成列向量,也就是<br>$$<br>x = (500,240,25,13,2312.15)^{T}<br>$$<br>这样对于m行的n维数据就可以表示成<br>$$<br>X = (x_{1}, x_{2},\cdots,x_{n})<br>$$<br>$x_{i}$都是列向量</p><h4 id="向量的内积"><a href="#向量的内积" class="headerlink" title="向量的内积"></a>向量的内积</h4><p>向量$A=(a_{1}, a_{2},\cdots,a_{n})^{T}$与向量$B=(b_{1}, b_{2}, \cdots, b_{n})^{T}$的内积表示如下:<br>$$<br>A\cdot B=a_{1}b_{1}+a_{2}b_{2}+\cdots+a_{n}b_{n}=\sum_{i=1}^{n}a_{i}b_{i}<br>$$<br>为了方便看到几何关系,把内积写成$A\cdot B=|A||B|\cos(\alpha)$内积也就是A在B方向上的投影,当B的模为1的时候就可以简化成<br>$$<br>A\cdot B= |A|\cos(\alpha)<br>$$<br><strong>设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度</strong></p><h4 id="向量的基"><a href="#向量的基" class="headerlink" title="向量的基"></a>向量的基</h4><p>以二维向量$A=(3,2)$为例,我们很熟悉的表示成直角坐标系的点$(3,2)$,这里要注意的是采用直角坐标系的同时是默认了x,y轴上各自长度为1的单位向量$(1,0), (0,1)$作为基,又上面内积的解释可以看到向量$A =  3(1,0)^{T}+2(0,1)^{T}$.</p><blockquote><p>我们之所以默认选择(1,0)和(0,1)为基，当然是比较方便，因为它们分别是x和y轴正方向上的单位向量，因此就使得二维平面上点坐标和向量一一对应，非常方便。但实际上任何两个线性无关的二维向量都可以成为一组基，所谓线性无关在二维平面内可以直观认为是两个不在一条直线上的向量。</p></blockquote><p>例如，(1,1)和(-1,1)也可以成为一组基。一般来说，我们希望基的模是1，因为从内积的意义可以看到，如果基的模是1,实际上，对应任何一个向量我们总可以找到其同方向上模为1的向量,只要让两个分量分别除以模即可.得到单位基向量$(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}}),(-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}})$</p><p>现在，我们想获得(3,2)在新基上的坐标，即在两个方向上的投影矢量值，那么根据内积的几何意义，我们只要分别计算(3,2)和两个基的内积，不难得到新的坐标为$(\frac{5}{\sqrt{2}},-\frac{1}{\sqrt{2}})$下图给出了新的基以及(3,2)在新基上坐标值的示意图：</p><p><img src="/2018/05/10/PCA-主成成分分析-学习笔记/05.png" alt="基转化"></p><h4 id="向量基变换"><a href="#向量基变换" class="headerlink" title="向量基变换"></a>向量基变换</h4><blockquote><p>两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去</p></blockquote><p>对于更一般的情况,$N$维空间$m$个向量进行基变换,变换到$R$个$N$维向量为基的空间中,</p><p>将基向量按行组成矩阵$A=(p_{1},p_{2},\cdots,p_{N})^{T}$,其中$p_{i}={p_{i1},p_{i2},\cdots,p_{i_N}}$</p><p>将m个N维向量按列组成矩阵$B$,则$A\cdot B$就是变换后的结果组成的矩阵</p><p><img src="/2018/05/10/PCA-主成成分分析-学习笔记/基变换.png" alt="基变换公式"></p><p>行向量$p_{i}$表示第i个基,列向量$x_{j}$就表示第j个向量,右侧矩阵对应m列也就是变换之后的m个R维向量</p><p>由于这里R可以小于N,所以也就实现了降维.</p><h4 id="降维的约束条件"><a href="#降维的约束条件" class="headerlink" title="降维的约束条件"></a>降维的约束条件</h4><p>到上面的基变换我们也就初步可以实现降维了,但是现在的问题是怎样降维才是最好的,使损失最小?例如,有$(2,1),(0,1)$这两个向量,想降到一维,也就是投影到某个方向的直线上,如果选取x轴方向就是两个点0,2,但如果选取y轴方向,两个点的变换结果就重合了,这时候就损失掉了一个点,这样的变换就是不好的,所以这里就要解决这样的问题,让变换之后的结果尽可能多的保留.</p><p>显然,变换后的结果要尽可能的分散,离散开来就可以减少损失,这里我们用<strong>方差</strong>衡量上述一维变换的结果的离散程度,方差公式<br>$$<br>Var(x) = \frac{1}{m}\sum_{i=1}^{m}(x_{i}-\mu)^{2}<br>$$<br>由于处理前对数据进行平均值为0的处理,结果简化为<br>$$<br>V(x)=\frac{1}{m}\sum_{i=1}^{m}x^{2}_{i}<br>$$<br>这时候也就是找到一个一维的方向使得结果的方差最大即可</p><p>现在有另外一个问题就是,变换后的维度超过一维的话,比如三维到二维的变换,是要先确定一个维度,再确定另一个,如果都按照这个方差最大来实现,那么这两个维度应该是”重合”的了,显然还要另外一个条件来约束,使得我们确定一个维度之后,其他的维度不能与他”重合”,这里就使用了<strong>协方差</strong>,所谓的”重合”也就是这两个维度过分相关,而我们希望他们最好是没有线性相关性的,而这个相关性就是用协方差表示,<br>$$<br>Cov(X,Y)=E((X-\mu)(Y-\nu))<br>$$<br>同样由于对数据都已经均值为0处理,协方差也可以简化<br>$$<br>Cov(X,Y) = \frac{1}{m}\sum_{i=1}^{m}x_{i}y_{i}<br>$$<br>这样就可以求得两个方向的相关性,让其非线性相关也就是协方差为0,也就是在前一个向量的正交方向上选择,这里也就验证了,我们习惯性建系后选取$(0,1),(1,0)$两个线性无关方向作为基,</p><p>到这就找到降维的优化目标:<strong>从$N$维降到$R$维时,选取$R$个正交基使得变换之后各字段方差最大,各自间协方差为0</strong></p><h4 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h4><p>到这里,引入协方差矩阵,对于矩阵$X$称$C = \frac{1}{m}XX^{T}$是X的协方差矩阵</p><p>如m个二维向量组成<br>$$<br>X =\begin{pmatrix} x_{1} &amp; x_{2}  &amp; \cdots &amp;x_{m} \\<br>y_{1} &amp; y_{2}  &amp; \cdots &amp;y_{m}<br>\end{pmatrix}<br>$$<br>求出协方差矩阵</p><p><img src="/2018/05/10/PCA-主成成分分析-学习笔记/协方差矩阵.png" alt="协方差矩阵"></p><p>协方差矩阵中完美包含了上面讨论的两个因素,方差和协方差,并且对角线上是方差,此外i行j列与j行i列是同一个协方差</p><h4 id="协方差矩阵对角化"><a href="#协方差矩阵对角化" class="headerlink" title="协方差矩阵对角化"></a>协方差矩阵对角化</h4><p>上面协方差矩阵引入之后,就可以发现,优化降维条件就是对协方差矩阵对角化,除了对角线外其他元素都是0(协方差为0),然后按照对角线上元素(方差)从大到小选取前R个,就是我们降维之后的R个正交基.</p><p>验证:假设原始$X$对应的协方差矩阵$C$,$P$是一组基按行组成的矩阵(降维的矩阵),设结果为Y,$Y=P\cdot X$,则表示Y的协方差D可得:<br>$$<br>D = \frac{1}{m}YY^{T}<br>=\frac{1}{m}PXX^{T}P^{T}<br>=P(\frac{1}{m}XX^{T})P^{T}<br>=PCP^{T}<br>$$<br>这也就验证了目标基组成的矩阵就是让协方差对角化的矩阵P,只要找到对角矩阵,然后按照对角元素从大到小选取前R个,即可找到变换的R维基,接着就是求解矩阵对角化,详细内容可以自己看一下线代里面的推到,这里就博客内容简要整理.</p><p>一个N维实对称方阵(协方差矩阵)一定可以找到N个正交的特征向量,记为$e_{1}, e_{2},\cdots,e_{N}$,按列组成矩阵<br>$$<br>E = (e_{1}, e_{2},\cdots,e_{N})<br>$$<br>对协方差运算<br>$$<br>E^{T}CE = \Lambda=\begin{pmatrix} \lambda_{1} \\<br>&amp; \lambda_{2} \\<br>&amp;&amp; \ddots\\<br>&amp;&amp;&amp;&amp; \lambda_{N}<br>\end{pmatrix}<br>$$<br>$\Lambda$就是目标对角矩阵,其中对角线上元素就是特征向量对应的特征值,所以目标的基就是$E^{T}$</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>$$<br>X = \begin{pmatrix}1 &amp; 1&amp; 2&amp; 4 &amp;2\\<br>1 &amp; 3 &amp; 3&amp;４&amp;４<br>\end{pmatrix}<br>$$</p><p>用$PCA$降维到1维</p><p>首先,对各个字段均值0化处理得到<br>$$<br>X = \begin{pmatrix} -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0\\<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\end{pmatrix}<br>$$<br>求出协方差矩阵$C$<br>$$<br>C = \frac{1}{5}<br>\begin{pmatrix} -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0\\<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\end{pmatrix}<br>\begin{pmatrix}<br>-1 &amp; -2 \\<br>-1 &amp; 0 \\<br>0 &amp; 0\\<br>2 &amp; 1\\<br>0 &amp; 1<br>\end{pmatrix}<br>= \begin{pmatrix}<br>\frac{6}{5} &amp; \frac{4}{5}\\<br>\frac{4}{5} &amp; \frac{6}{5}<br>\end{pmatrix}<br>$$<br>求解$C$的特征值:<br>$$<br>\lambda_{1} = 2, \lambda_{2} = 0.4<br>$$<br>降到1维,选取两者中大的那个$\lambda_{1} = 2$</p><p>求解一个特征向量<br>$$<br>c_{1} =\begin{pmatrix}<br>1 \\<br>1<br>\end{pmatrix}<br>$$<br>标准化特征向量后<br>$$<br>c = \begin{pmatrix}<br>\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}}<br>\end{pmatrix}<br>$$<br>求出结果<br>$$<br>Y = c\cdot X =\begin{pmatrix} -\frac{3}{\sqrt2} &amp;-\frac{1}{\sqrt2} &amp;0 &amp;\frac{3}{\sqrt2} &amp;-\frac{1}{\sqrt2} &amp;<br>\end{pmatrix}<br>$$</p><hr><p>参考内容:</p><p><a href="http://blog.codinglabs.org/articles/pca-tutorial.html" target="_blank" rel="noopener">PCA数学原理</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E6%96%B9%E5%B7%AE" target="_blank" rel="noopener">协方差矩阵</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;做机器学习训练时会遇到这样一个:原始数据特征的维度特别高,不利于模型的训练.这时候我们需要对原始数据的特征向量进行降维处理，然后将降维后的数
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="PCA" scheme="http://yoursite.com/tags/PCA/"/>
    
  </entry>
  
  <entry>
    <title>Django2.0博客教程(四)功能完善</title>
    <link href="http://yoursite.com/2018/05/05/Django2-0%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B-%E5%9B%9B-%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84/"/>
    <id>http://yoursite.com/2018/05/05/Django2-0博客教程-四-功能完善/</id>
    <published>2018-05-05T15:19:57.000Z</published>
    <updated>2018-05-05T15:19:57.602Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Django2-0博客教程(三)更多页面的实现</title>
    <link href="http://yoursite.com/2018/05/05/Django2-0%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B-%E4%B8%89-%E6%9B%B4%E5%A4%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/05/05/Django2-0博客教程-三-更多页面的实现/</id>
    <published>2018-05-05T06:47:13.000Z</published>
    <updated>2018-05-05T08:39:54.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文章详情-分类-标签-归档视图"><a href="#文章详情-分类-标签-归档视图" class="headerlink" title="文章详情/分类/标签/归档视图"></a>文章详情/分类/标签/归档视图</h3><p>博客的主页已经可以运行了,这里就给博客添加更多的功能,也就是在<code>views.py</code>中添加更多的视图函数</p><h4 id="文章详情函数"><a href="#文章详情函数" class="headerlink" title="文章详情函数"></a>文章详情函数</h4><p>修改<code>blog/views.py</code>,添加<code>detail</code>函数,用于显示文章内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, post_id)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    文章详情页</span></span><br><span class="line"><span class="string">    :param request: 请求</span></span><br><span class="line"><span class="string">    :param post_id: 文章id</span></span><br><span class="line"><span class="string">    :return: post page</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        post = Article.objects.get(id=str(post_id))     <span class="comment"># 通过id获取文章实体</span></span><br><span class="line">        post.viewed()                                   <span class="comment"># 更新浏览次数</span></span><br><span class="line">        tags = post.tags.all()                          <span class="comment"># 获取文章对应所有标签</span></span><br><span class="line">    <span class="keyword">except</span> Article.DoesNotExist:</span><br><span class="line">        <span class="keyword">raise</span> Http404</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'post.html'</span>, &#123;<span class="string">'post'</span>: post,</span><br><span class="line">                                         <span class="string">'tags'</span>: tags,&#125;)</span><br></pre></td></tr></table></figure><h4 id="分类函数"><a href="#分类函数" class="headerlink" title="分类函数"></a>分类函数</h4><p>添加<code>category</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">category</span><span class="params">(request, category_id)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    文章详情页</span></span><br><span class="line"><span class="string">    :param request: 请求</span></span><br><span class="line"><span class="string">    :param category_id: 分类id</span></span><br><span class="line"><span class="string">    :return: category page</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    posts = Article.objects.filter(category_id=str(category_id))</span><br><span class="line">    category = categories.get(id=str(category_id))    <span class="comment"># 通过id获取分类实体</span></span><br><span class="line">    paginator = Paginator(posts, settings.PAGE_NUM)   <span class="comment"># 获取文章对应所有标签</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        page = request.GET.get(<span class="string">'page'</span>)   <span class="comment"># 获取URL中page参数的值</span></span><br><span class="line">        post_list = paginator.page(page)</span><br><span class="line">    <span class="keyword">except</span> PageNotAnInteger:</span><br><span class="line">        post_list = paginator.page(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> EmptyPage:</span><br><span class="line">        post_list = paginator.page(paginator.num_pages)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'category.html'</span>, &#123;<span class="string">'post_list'</span>: post_list,</span><br><span class="line">                                             <span class="string">'category'</span>: category,&#125;)</span><br></pre></td></tr></table></figure><h4 id="标签函数"><a href="#标签函数" class="headerlink" title="标签函数"></a>标签函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(request, tag)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    文章详情页</span></span><br><span class="line"><span class="string">    :param request: 请求</span></span><br><span class="line"><span class="string">    :param tag: 标签内容</span></span><br><span class="line"><span class="string">    :return: tag page</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    posts = Article.objects.filter(tags__name__contains=tag)</span><br><span class="line">    paginator = Paginator(posts, settings.PAGE_NUM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        page = request.GET.get(<span class="string">'page'</span>)</span><br><span class="line">        post_list = paginator.page(page)</span><br><span class="line">    <span class="keyword">except</span> PageNotAnInteger:</span><br><span class="line">        post_list = paginator.page(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> EmptyPage:</span><br><span class="line">        post_list = paginator.page(paginator.num_pages)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'tag.html'</span>, &#123;<span class="string">'post_list'</span>: post_list,</span><br><span class="line">                                        <span class="string">'tag'</span>: tag&#125;)</span><br></pre></td></tr></table></figure><h4 id="归档函数"><a href="#归档函数" class="headerlink" title="归档函数"></a>归档函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">archives</span><span class="params">(request, year, month)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    归档页面</span></span><br><span class="line"><span class="string">    :param request: 请求</span></span><br><span class="line"><span class="string">    :param year: 年份</span></span><br><span class="line"><span class="string">    :param month: 月份</span></span><br><span class="line"><span class="string">    :return: archives page</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    posts = Article.objects.filter(pub_time__year=year, pub_time__month=month).order_by(<span class="string">'-pub_time'</span>)</span><br><span class="line">    paginator = Paginator(posts, settings.PAGE_NUM)  <span class="comment"># 每页显示数量</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        page = request.GET.get(<span class="string">'page'</span>)  <span class="comment"># 获取URL中page参数的值</span></span><br><span class="line">        post_list = paginator.page(page)</span><br><span class="line">    <span class="keyword">except</span> PageNotAnInteger:</span><br><span class="line">        post_list = paginator.page(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> EmptyPage:</span><br><span class="line">        post_list = paginator.page(paginator.num_pages)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'archive.html'</span>, &#123;</span><br><span class="line">        <span class="string">'post_list'</span>: post_list,</span><br><span class="line">        <span class="string">'category_list'</span>: categories,</span><br><span class="line">        <span class="string">'months'</span>: months,</span><br><span class="line">        <span class="string">'year_month'</span>: year+<span class="string">'年'</span>+month+<span class="string">'月'</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h3><p>修改<code>blog/urls.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.home, name=<span class="string">'home'</span>),</span><br><span class="line">    path(<span class="string">'home/'</span>, views.home, name=<span class="string">'home'</span>),</span><br><span class="line">    path(<span class="string">'articles/&lt;int:post_id&gt;/'</span>, views.detail, name=<span class="string">'detail'</span>),</span><br><span class="line">    path(<span class="string">'category/&lt;int:category_id&gt;/'</span>, views.category, name=<span class="string">'category'</span>),</span><br><span class="line">    path(<span class="string">'tag/&lt;str:tag&gt;/'</span>, views.tag, name=<span class="string">'tag'</span>),</span><br><span class="line">    path(<span class="string">'archives/&lt;str:year&gt;/&lt;str:month&gt;'</span>, views.archives, name=<span class="string">'archives'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>为刚刚新写的几个函数添加对应的路由</p><p>启动项目,添加一些标签/分类.,创建文章就可以看到效果了</p><p><img src="/2018/05/05/Django2-0博客教程-三-更多页面的实现/分类.png" alt=""></p><h3 id="完善显示部分"><a href="#完善显示部分" class="headerlink" title="完善显示部分"></a>完善显示部分</h3><p>在<code>base.html</code>中显示分类和归档详情,但是上述几个视图函数仅仅实现了自己的功能,并没有传入分类和归档信息,这里修改<code>blog/views.py</code>添加上相应信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个全局变量,后面每个函数都会用到</span></span><br><span class="line">categories = Category.objects.all()  <span class="comment"># 获取全部的分类对象</span></span><br><span class="line">months = Article.objects.values_list(<span class="string">'pub_time'</span>, flat=<span class="keyword">True</span>)  <span class="comment"># 获取文章时间归档</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在每个函数最后的传参部分添加 months和category_list参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    主页视图</span></span><br><span class="line"><span class="string">    :param request: 请求</span></span><br><span class="line"><span class="string">    :return: homepage</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    posts = Article.objects.all()                       <span class="comment"># 获取全部的Article对象</span></span><br><span class="line">    paginator = Paginator(posts, settings.PAGE_NUM)     <span class="comment"># 每页显示数量，对应settings.py中的PAGE_NUM</span></span><br><span class="line">    page = request.GET.get(<span class="string">'page'</span>)                      <span class="comment"># 获取URL中page参数的值</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        post_list = paginator.page(page)</span><br><span class="line">    <span class="keyword">except</span> PageNotAnInteger:</span><br><span class="line">        post_list = paginator.page(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> EmptyPage:</span><br><span class="line">        post_list = paginator.page(paginator.num_pages)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'home.html'</span>, &#123;<span class="string">'post_list'</span>: post_list,</span><br><span class="line">                                         <span class="string">'months'</span>: months,   <span class="comment"># 注意添加的months</span></span><br><span class="line">                                         <span class="string">'category_list'</span>: categories&#125;)  <span class="comment"># 注意添加的category_list</span></span><br><span class="line"><span class="comment"># 每个函数都添加这两个变量</span></span><br></pre></td></tr></table></figure><p>完整的最终代码可以在github的项目中看到,到这页面显示部分就完成了</p><h4 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h4><p>如果后端使用的是MySql,可能会在在归档页面按照年月查询不到文章列表,这时由于Mysql中的时区转化问题导致查询结果总是为<code>NULL</code></p><p>解决办法:执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root mysql -p</span><br></pre></td></tr></table></figure><p>详细解决过程我是参考了这篇<a href="http://chowyi.com/2017/09/19/Django%E4%BD%BF%E7%94%A8MySQL%E5%90%8E%E7%AB%AF%E6%97%A5%E6%9C%9F%E4%B8%8D%E8%83%BD%E6%8C%89%E6%9C%88%E8%BF%87%E6%BB%A4%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文章详情-分类-标签-归档视图&quot;&gt;&lt;a href=&quot;#文章详情-分类-标签-归档视图&quot; class=&quot;headerlink&quot; title=&quot;文章详情/分类/标签/归档视图&quot;&gt;&lt;/a&gt;文章详情/分类/标签/归档视图&lt;/h3&gt;&lt;p&gt;博客的主页已经可以运行了,这里就给博
      
    
    </summary>
    
      <category term="Django博客教程" scheme="http://yoursite.com/categories/Django%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="博客教程" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Django2.0博客教程(二)_初步搭建博客</title>
    <link href="http://yoursite.com/2018/05/02/Django2-0%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B-%E4%BA%8C-%E5%88%9D%E6%AD%A5%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/05/02/Django2-0博客教程-二-初步搭建博客/</id>
    <published>2018-05-02T13:10:40.000Z</published>
    <updated>2018-05-05T07:37:44.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编辑博客model文件"><a href="#编辑博客model文件" class="headerlink" title="编辑博客model文件"></a>编辑博客model文件</h3><p>编辑<code>blog/model.py</code>,model部分也就是博客的数据库存储和操作部分,用于前后数据的交互</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.utils.timezone <span class="keyword">import</span> now</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    创建Tag模型</span></span><br><span class="line"><span class="string">    ==========</span></span><br><span class="line"><span class="string">    包含字段:</span></span><br><span class="line"><span class="string">    name</span></span><br><span class="line"><span class="string">    created_time</span></span><br><span class="line"><span class="string">    update_time</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name = models.CharField(verbose_name=<span class="string">'标签名'</span>, max_length=<span class="number">64</span>)</span><br><span class="line">    created_time = models.DateTimeField(verbose_name=<span class="string">'创建时间'</span>, default=now)</span><br><span class="line">    update_time = models.DateTimeField(verbose_name=<span class="string">'修改时间'</span>, default=now)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        设置显示名称</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        设置模型属性</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ordering = [<span class="string">'name'</span>]                 <span class="comment"># 按照name排序</span></span><br><span class="line">        verbose_name = <span class="string">'标签名称'</span>            <span class="comment"># 指定后台显示模型名称</span></span><br><span class="line">        verbose_name_plural = <span class="string">'标签列表'</span>     <span class="comment"># 指定后台显示模型复数名称</span></span><br><span class="line">        db_table = <span class="string">"tag"</span>                    <span class="comment"># 数据库表名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Category</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    创建分类模型</span></span><br><span class="line"><span class="string">    ==========</span></span><br><span class="line"><span class="string">    包含字段:</span></span><br><span class="line"><span class="string">    name</span></span><br><span class="line"><span class="string">    created_time</span></span><br><span class="line"><span class="string">    uopdate_time</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name = models.CharField(verbose_name=<span class="string">'类别名称'</span>, max_length=<span class="number">64</span>)</span><br><span class="line">    created_time = models.DateTimeField(verbose_name=<span class="string">'创建时间'</span>, default=now)</span><br><span class="line">    update_time = models.DateTimeField(verbose_name=<span class="string">'修改时间'</span>, default=now)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">'name'</span>]</span><br><span class="line">        verbose_name = <span class="string">"类别名称"</span></span><br><span class="line">        verbose_name_plural = <span class="string">'分类列表'</span></span><br><span class="line">        db_table = <span class="string">"category"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    创建文章模型</span></span><br><span class="line"><span class="string">    ==========</span></span><br><span class="line"><span class="string">    包含字段:</span></span><br><span class="line"><span class="string">    name</span></span><br><span class="line"><span class="string">    content</span></span><br><span class="line"><span class="string">    status</span></span><br><span class="line"><span class="string">    views</span></span><br><span class="line"><span class="string">    created_time</span></span><br><span class="line"><span class="string">    pub_time</span></span><br><span class="line"><span class="string">    update_time</span></span><br><span class="line"><span class="string">    categories</span></span><br><span class="line"><span class="string">    tags</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    STATUS_CHOICES = (</span><br><span class="line">        (<span class="string">'d'</span>, <span class="string">'草稿'</span>),</span><br><span class="line">        (<span class="string">'p'</span>, <span class="string">'发表'</span>),</span><br><span class="line">    )</span><br><span class="line">    title = models.CharField(verbose_name=<span class="string">'标题'</span>, max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField(verbose_name=<span class="string">'正文'</span>, blank=<span class="keyword">True</span>, null=<span class="keyword">True</span>)</span><br><span class="line">    status = models.CharField(verbose_name=<span class="string">'状态'</span>, max_length=<span class="number">1</span>, choices=STATUS_CHOICES, default=<span class="string">'p'</span>)</span><br><span class="line">    views = models.PositiveIntegerField(verbose_name=<span class="string">'浏览量'</span>, default=<span class="number">0</span>)</span><br><span class="line">    created_time = models.DateTimeField(verbose_name=<span class="string">'创建时间'</span>, default=now)</span><br><span class="line">    pub_time = models.DateTimeField(verbose_name=<span class="string">'发布时间'</span>, blank=<span class="keyword">True</span>, null=<span class="keyword">True</span>)</span><br><span class="line">    update_time = models.DateTimeField(verbose_name=<span class="string">'修改时间'</span>, default=now)</span><br><span class="line">    categories = models.ForeignKey(Category, verbose_name=<span class="string">'分类'</span>, on_delete=models.CASCADE, blank=<span class="keyword">False</span>, null=<span class="keyword">False</span>)</span><br><span class="line">    tags = models.ManyToManyField(Tag, verbose_name=<span class="string">'标签集合'</span>, blank=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">viewed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        浏览记录+1</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.views += <span class="number">1</span></span><br><span class="line">        self.save(update_fields=[<span class="string">'views'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_article</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取下一篇文章</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> Article.objects.filter(id__gt=self.id, status=<span class="string">'p'</span>, pub_time__isnull=<span class="keyword">False</span>).first()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prev_article</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取前一篇文章</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> Article.objects.filter(id__lt=self.id, status=<span class="string">'p'</span>, pub_time__isnull=<span class="keyword">False</span>).first()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">'-pub_time'</span>]                <span class="comment"># 按文章创建日期降序</span></span><br><span class="line">        verbose_name = <span class="string">'文章'</span>                    <span class="comment"># 指定后台显示模型名称</span></span><br><span class="line">        verbose_name_plural = <span class="string">'文章列表'</span>          <span class="comment"># 指定后台显示模型复数名称</span></span><br><span class="line">        db_table = <span class="string">'article'</span>                    <span class="comment"># 数据库表名</span></span><br><span class="line">        get_latest_by = <span class="string">'created_time'</span></span><br></pre></td></tr></table></figure><h4 id="注册模型"><a href="#注册模型" class="headerlink" title="注册模型"></a>注册模型</h4><p>编辑<code>blog/admin.py</code>文件,将模型绑定到admin上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Article, Category, Tag</span><br><span class="line"></span><br><span class="line">admin.site.register(Article)</span><br><span class="line">admin.site.register(Category)</span><br><span class="line">admin.site.register(Tag)</span><br></pre></td></tr></table></figure><p>进行数据库迁移</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>创建管理员身份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><p>填写信息之后,启动服务并登陆后台</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>访问<code>http://127.0.0.1:8000/admin/</code>登录刚刚创建的管理员就可以看到后台内容</p><p><img src="/2018/05/02/Django2-0博客教程-二-初步搭建博客/admin.png" alt="admin"></p><p>可以创建标签分类和文章</p><p><img src="/2018/05/02/Django2-0博客教程-二-初步搭建博客/创建文章.png" alt="创建文章"></p><h3 id="创建博客主页"><a href="#创建博客主页" class="headerlink" title="创建博客主页"></a>创建博客主页</h3><p>在<code>settings.py</code>中添加主页显示页数的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">USE_L10N = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">USE_TZ = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">PAGE_NUM = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>在最后添加<code>PAGE_NUM</code>,便于在后面使用分页时对页数的管理</p><p>在<code>blog</code>下创建<code>static</code>文件夹,把博客的静态文件都放进去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── css</span><br><span class="line">├── fonts</span><br><span class="line">├── image</span><br><span class="line">└── js</span><br></pre></td></tr></table></figure><p>在项目根目录下创建<code>templates</code>文件夹,把模板文件放进去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── archive.html</span><br><span class="line">├── base.html</span><br><span class="line">├── category.html</span><br><span class="line">├── home.html</span><br><span class="line">├── post.html</span><br><span class="line">└── tag.html</span><br></pre></td></tr></table></figure><p>编辑<code>blog/view.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> blog.models <span class="keyword">import</span> Article</span><br><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator, PageNotAnInteger, EmptyPage</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    主页视图</span></span><br><span class="line"><span class="string">    :param request: 请求</span></span><br><span class="line"><span class="string">    :return: homepage</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    posts = Article.objects.all()                       <span class="comment"># 获取全部的Article对象</span></span><br><span class="line">    paginator = Paginator(posts, settings.PAGE_NUM)     <span class="comment"># 每页显示数量，对应settings.py中的PAGE_NUM</span></span><br><span class="line">    page = request.GET.get(<span class="string">'page'</span>)                      <span class="comment"># 获取URL中page参数的值</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        post_list = paginator.page(page)</span><br><span class="line">    <span class="keyword">except</span> PageNotAnInteger:</span><br><span class="line">        post_list = paginator.page(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> EmptyPage:</span><br><span class="line">        post_list = paginator.page(paginator.num_pages)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'home.html'</span>, &#123;<span class="string">'post_list'</span>: post_list&#125;)</span><br></pre></td></tr></table></figure><h3 id="创建博客主页路由"><a href="#创建博客主页路由" class="headerlink" title="创建博客主页路由"></a>创建博客主页路由</h3><p>在<code>blog</code>中创建<code>urls.py</code>并编辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.home, name=<span class="string">'home'</span>),</span><br><span class="line">    path(<span class="string">'home/'</span>, views.home, name=<span class="string">'home'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后编辑<code>myblog/urls.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">''</span>, include(<span class="string">'blog.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后启动服务就可以看到主页了</p><p><img src="/2018/05/02/Django2-0博客教程-二-初步搭建博客/主页.png" alt="主页"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编辑博客model文件&quot;&gt;&lt;a href=&quot;#编辑博客model文件&quot; class=&quot;headerlink&quot; title=&quot;编辑博客model文件&quot;&gt;&lt;/a&gt;编辑博客model文件&lt;/h3&gt;&lt;p&gt;编辑&lt;code&gt;blog/model.py&lt;/code&gt;,model
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Django2.0博客教程(一)_创建项目</title>
    <link href="http://yoursite.com/2018/05/01/Django2-0%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B-%E4%B8%80-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2018/05/01/Django2-0博客教程-一-创建项目/</id>
    <published>2018-05-01T15:34:24.000Z</published>
    <updated>2018-05-05T08:51:55.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用pipenv创建项目"><a href="#使用pipenv创建项目" class="headerlink" title="使用pipenv创建项目"></a>使用pipenv创建项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir project</span><br><span class="line">cd project</span><br></pre></td></tr></table></figure><p>进入环境目录后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pipenv install django</span><br><span class="line">pipenv shell</span><br></pre></td></tr></table></figure><p>这样就进入了虚拟环境, pipenv大大简化了之前配置虚拟环境的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject myblog</span><br><span class="line">cd myblog</span><br><span class="line">django-admin startapp blog</span><br></pre></td></tr></table></figure><p>这样就创建了我们的Django博客项目,注意创建Django项目时的操作都是在pipenv-shell中的</p><h2 id="运行Django项目"><a href="#运行Django项目" class="headerlink" title="运行Django项目"></a>运行Django项目</h2><h3 id="初始化项目的配置分析"><a href="#初始化项目的配置分析" class="headerlink" title="初始化项目的配置分析"></a>初始化项目的配置分析</h3><p>Django项目的目录大致如下, 其中我们会涉及到的部分我简要标记了一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── blog-- app文件目录</span><br><span class="line">│   ├── admin.py</span><br><span class="line">│   ├── apps.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── migrations-- 数据库迁移</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   ├── models.py-- model层</span><br><span class="line">│   ├── tests.py</span><br><span class="line">│   └── views.py-- view层</span><br><span class="line">├── manage.py    -- 项目管理脚本</span><br><span class="line">└── myblog    -- 项目配置文件夹</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── settings.py-- 项目配置信息</span><br><span class="line">    ├── urls.py-- 项目url</span><br><span class="line">    └── wsgi.py</span><br></pre></td></tr></table></figure><p>进入到<code>myblog/settings.py</code>中,注意下面几个地方</p><h4 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>这是开发者模式,默认开启DEBUG,有助于我们开发过程中的调试,开启后会返回运行的异常信息,所以在上线之后一定要关闭DEBUG</p><h4 id="INSTALLED-APPS"><a href="#INSTALLED-APPS" class="headerlink" title="INSTALLED_APPS"></a>INSTALLED_APPS</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这是项目中要加载的app,上面都是默认的Django自带的一些库,比如<code>admin</code>这个后面也会讲到,我们之前创建了一个blog应用,仅仅是创建了Django是不知道的,要在这里添加进去才可以在项目中运行blog部分,在最后添加上<code>blog</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'blog'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="DATABASES"><a href="#DATABASES" class="headerlink" title="DATABASES"></a>DATABASES</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.sqlite3'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: os.path.join(BASE_DIR, <span class="string">'db.sqlite3'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是项目的数据库信息,这里用的是Django的默认配置<code>sqlite</code>的数据库,如果需要修改成其他的 ,修改掉<code>sqlite</code>并添加上对应的数据库信息就行,虽然这个blog系统很简单用<code>sqlite</code>就可以了,不过为了学习起见,这里采用MySql</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'dbname'</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'username'</span>,    </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'password'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'hostname'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="string">'3306'</span>,</span><br><span class="line">        <span class="string">'CHARSET'</span>:<span class="string">'utf8'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应修改上面的mysql信息即可</p><p>要注意的是</p><ol><li><p><code>CHARSET</code>是指定编码格式, 这里的编码一定要和数据库创建时的编码一致才行,否做就会出现乱码报错,创建数据库时最好就手动指定编码格式(如下),如果你想要抓取一些评论信息,由于评论中有表情符号,要采用<code>utf8mb4</code>,数据库和django都指定成<code>utf8mb4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database dbname character set &apos;utf8&apos;;</span><br></pre></td></tr></table></figure></li><li><p>切换成Mysql引擎后Django运行可能会提示没有<code>mysqlclient</code>,如果pipenv安装报错,请尝试先安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sduo apt install libmysqlclinet-dev</span><br></pre></td></tr></table></figure></li><li><p>如果使用其他的数据库比如类似的写好配置信息并安装所需的操作库即可</p></li></ol><h4 id="时区和语言"><a href="#时区和语言" class="headerlink" title="时区和语言"></a>时区和语言</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">'en-us'</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">'UTC'</span></span><br></pre></td></tr></table></figure><p>Django默认的是英语和UTC时区,时区的不一致会导致后面在数据库中插入和读取时间的不一致问题,这里我们改成<code>Asia/Shanghai</code></p><p>至于语言也可以更换成中文,不过这个不怎么重要,更换成中文的话,修改成<code>zh-Hans</code>即可,另外其他的时区和语言可以自行搜索一下就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">'zh-Hans'</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span><br></pre></td></tr></table></figure><h4 id="TEMPLATES"><a href="#TEMPLATES" class="headerlink" title="TEMPLATES"></a>TEMPLATES</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [],</span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注意<code>DIRS</code>是模板的路径,可以自己指定,但为了方便在项目目录下创建<code>templates</code>文件夹即可</p><p>其他部分<code>BACKEND</code>和<code>OPTIONS</code>可以更换成其他的模板引擎,博客项目用默认的</p><p>如果用的PyCharm创建会默认生成模板路径,没有的话手动添加一下路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>), ],</span><br></pre></td></tr></table></figure><h4 id="STATIC"><a href="#STATIC" class="headerlink" title="STATIC"></a>STATIC</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br></pre></td></tr></table></figure><p>指定app中静态文件路径,在上线之后,Django会把静态文件全部打包到一个路径下方便部署</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line"><span class="comment"># STATIC_ROOT 文件夹 是用来将所有STATICFILES_DIRS中所有文件夹中的文件，以及各app中static中的文件都复制过来</span></span><br><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">'collected_static'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 用来存放项目中公用的静态文件，里面不能包含 STATIC_ROOT</span></span><br><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">"common_static"</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>STATIC_ROOT</code>是在执行<code>collectstatic</code>之后把静态文件复制到的目录,<code>STATICFILES_DIRS</code>是项目中的app可以共享的静态文件目录,<code>STATIC_URL</code>则是app的静态目录</p><p>静态文件内容可以自行去文档中了解,也可以在后面的开发过程中会遇到时边做变了解</p><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>这样就可以在127.0.0.1:8000端口处看到项目效果了</p><p><img src="/2018/05/01/Django2-0博客教程-一-创建项目/初始化项目.png" alt="初始化项目"></p><p>(语言切换成了中文)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用pipenv创建项目&quot;&gt;&lt;a href=&quot;#使用pipenv创建项目&quot; class=&quot;headerlink&quot; title=&quot;使用pipenv创建项目&quot;&gt;&lt;/a&gt;使用pipenv创建项目&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Django博客教程" scheme="http://yoursite.com/categories/Django%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="博客教程" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>pipenv使用简记</title>
    <link href="http://yoursite.com/2018/05/01/pipenv%E4%BD%BF%E7%94%A8%E7%AE%80%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/05/01/pipenv使用简记/</id>
    <published>2018-05-01T15:08:45.000Z</published>
    <updated>2018-05-01T15:24:09.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用pipenv"><a href="#使用pipenv" class="headerlink" title="使用pipenv"></a>使用pipenv</h3><p>pipenv现在已经是官方推荐的包管理工具了,从命名上就能感受到它是集合了pip和virtualenv,对每一个项目单独的创建虚拟环境,创造相对独立的虚拟环境,类似于npm在项目中安装包的效果</p><h3 id="安装pipenv"><a href="#安装pipenv" class="headerlink" title="安装pipenv"></a>安装pipenv</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pipenv</span><br></pre></td></tr></table></figure><p>安装出现问题的话先检查下pip版本</p><p>权限问题的话就是带上sudo安装</p><h3 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir project_name</span><br><span class="line">cd project_name</span><br></pre></td></tr></table></figure><p>创建项目位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv install</span><br></pre></td></tr></table></figure><p>这样就在当前文件夹下生成了虚拟环境的配置文件, 都很类似与npm的使用了</p><p>文件夹下生成基本配置文件,</p><blockquote><p>Pipfile 里有最新安装的包文件的信息，如名称、版本等。用来 在重新安装项目依赖或与他人共享项目时，你可以用 Pipfile 来跟踪项目依赖。</p></blockquote><blockquote><p>Pipfile.lock 则包含你的系统信息，所有已安装包的依赖包及其版本信息，以及所有安装包及其依赖包的 Hash 校验信息。</p></blockquote><p>进入项目环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure><p>进入到虚拟环境中操作,注意pipenv与virtualens直接创建不同的是,生成的配置文件都在<code>.local/share/virtualenvs/</code>目录下</p><p>可以通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv --venv</span><br></pre></td></tr></table></figure><p>查看配置文件信息</p><h3 id="一些基本使用"><a href="#一些基本使用" class="headerlink" title="一些基本使用"></a>一些基本使用</h3><p>安装需要的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv install lib_name</span><br></pre></td></tr></table></figure><p>更新库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv update</span><br></pre></td></tr></table></figure><p>注意这个操作会删除所有库然后安装最新版</p><p>删除安装的库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv uninstall lib_name</span><br></pre></td></tr></table></figure><p>把库名称换成参数<code>--all</code>则是删除所有库</p><p>查看库之间的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv graph</span><br></pre></td></tr></table></figure><p>帮助信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv -h</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用pipenv&quot;&gt;&lt;a href=&quot;#使用pipenv&quot; class=&quot;headerlink&quot; title=&quot;使用pipenv&quot;&gt;&lt;/a&gt;使用pipenv&lt;/h3&gt;&lt;p&gt;pipenv现在已经是官方推荐的包管理工具了,从命名上就能感受到它是集合了pip和virtu
      
    
    </summary>
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pipenv" scheme="http://yoursite.com/tags/pipenv/"/>
    
  </entry>
  
  <entry>
    <title>从正则直接到DFA</title>
    <link href="http://yoursite.com/2018/04/21/%E4%BB%8E%E6%AD%A3%E5%88%99%E7%9B%B4%E6%8E%A5%E5%88%B0DFA/"/>
    <id>http://yoursite.com/2018/04/21/从正则直接到DFA/</id>
    <published>2018-04-21T13:02:06.000Z</published>
    <updated>2018-04-22T13:44:14.008Z</updated>
    
    <content type="html"><![CDATA[<p>大致三个步骤:</p><ol><li>生成抽象语法树</li><li>计算<code>followpos</code></li><li>生成DFA</li></ol><p>原理: 重要状态</p><h3 id="以-a-b-abb-为例"><a href="#以-a-b-abb-为例" class="headerlink" title="以$(a|b)^{*}abb$为例"></a>以$(a|b)^{*}abb$为例</h3><h4 id="生成抽象语法树"><a href="#生成抽象语法树" class="headerlink" title="生成抽象语法树"></a>生成抽象语法树</h4><p>首先给正则表达式加上#作为结束符,保证接受状态是重要状态,生成抽象语法树</p><p><img src="/2018/04/21/从正则直接到DFA/抽象语法树.png" alt="抽象语法树"></p><p>注意: 可以给每个标号赋予序号id,方便后面使用时区分</p><h4 id="计算followpos函数-重点"><a href="#计算followpos函数-重点" class="headerlink" title="计算followpos函数(重点)"></a>计算followpos函数(重点)</h4><p>先理解下<code>nullable</code> ,<code>firstpos</code>, <code>lastpos</code>,<code>followpos</code>含义</p><p><strong>nullable</strong>(n):是返回以n为根节点的子表达式表示的语言中是否包含空串$\epsilon$如果可以包含就返回true.</p><p><img src="/2018/04/21/从正则直接到DFA/nullable.png" alt="nullable"></p><p>注意图中的两个节点,$n_{1}$处表示$(a|b)^{<em>}a$,虽然$(a|b)^{</em>}$可以是$\epsilon$但是接上一个$a$后不可能产生空串,所以$nullable(n_{1})=false$</p><p>$n_{2}$处表示$(a|b)^{*}$显然可以生成$\epsilon$所以$nullable(n_{2})=true$</p><p><strong>firstpos</strong>(n):返回的是一个集合,包含以n为跟的子表达式所能生成的语言中串的第一个符号集合.</p><p>依然看上图中的$n_{1}$处,表示的是$(a|b)^{*}a$,可以生成的语言有$\lbrace a, aa, aaa, aba, ba,\cdots  \rbrace$</p><p>第一个a是$(a|b)^{*}$为$\epsilon$时,也就是id为3的a,此时3就是结果集中的一个元素</p><p>$aa$的第一个$a$则是$(a|b)^{*}$只有一个$a$,即1作为结果集一个元素</p><p>同样的$ba$可以看到2也是作为结果集一个元素</p><p>所以$firstpos(n_{1})=\lbrace 1,2,3\rbrace$</p><p><strong>lastpos</strong>(n): 返回的也是一个集合,和firstpos对应,返回的是所有串的结束符号集合</p><p>依然以$n_{1}$为例,参考<code>nullable</code>,<code>firstpos</code>中的分析可以看出所有串都会以$a$结束,所以$lastpos=\lbrace a\rbrace$</p><p>到这里就可以对每个节点进行<code>firstpos</code>和<code>lastpos</code>判断,把结果写在节点前(firstpos)后(lastpos)方便后面的运算</p><p><img src="/2018/04/21/从正则直接到DFA/前后标记.png" alt="带标记的抽象语法树"></p><p><strong>followpos</strong>(n): 这个函数是最重要的, </p><p>定义emmm感觉有点绕,</p><p><img src="/2018/04/21/从正则直接到DFA/followpos.png" alt="定义"></p><p>构造算法:</p><p><img src="/2018/04/21/从正则直接到DFA/构造算法.png" alt="构造算法"></p><p>结合这两条算法跟上面生成的图就可以对应写出followpos的结果表了</p><p>其实简单的来说$followpos(n)$就是在正则表示语言的所有串中找到n后面可以接的字符</p><p>比如对1 $a$来说,$followpos(1)$,可以在firstpos的分析中看到,</p><p>1a后面可以接1a,比如aaa开头的串(firstpos中的串集不是正则语言的串集合,没有带上bb结尾,但是开始部分是一样的),所以$followpos(1)$中含有1</p><p>1a后面可以接2b, 比如上面的aba, 所以结果集中含有2</p><p>1a后面还可以接3a,比如aa就是1a3a这样的 所以结果集中含有3</p><p>在其他的就不可能了,4,5,6是不可能的了,都是在后面拼接的字符,不可能直接相邻</p><p>结果表如下</p><p><img src="/2018/04/21/从正则直接到DFA/follow表.png" alt="定义"></p><p>可以画出followpos的有向图</p><p><img src="/2018/04/21/从正则直接到DFA/有向图.png" alt="定义"></p><h4 id="生成DFA"><a href="#生成DFA" class="headerlink" title="生成DFA"></a>生成DFA</h4><p>从生成的<code>followpos</code>结果表第一个开始,$A=\lbrace1,2,3\rbrace$,分别找a和b,可以划分为$a=&gt;\lbrace1,3\rbrace, b=&gt;\lbrace 2\rbrace$所以接一个a的转化是<br>$$<br>B = Drant[A,a] = followpos(1)\cup followpos(3)=\lbrace1,2,3\rbrace\cup\lbrace4\rbrace=\lbrace1,2,3,4\rbrace<br>$$<br>这个过成就跟用子集构造法从NFA到DFA类似,每个当前状态找寻下一个接a和接b的新状态,注意的就是新状态的生成过程也是不断用<code>followpos</code>计算的即可</p><p>注意,所有包含#的状态是DFA中的接受状态,这里也就是含有id为6的状态就是接受状态</p><p>生成的DFA</p><p><img src="/2018/04/21/从正则直接到DFA/DFA生成图.png" alt="定义"></p><h4 id="最小化DFA"><a href="#最小化DFA" class="headerlink" title="最小化DFA"></a>最小化DFA</h4><p>最小化算法跟前面一片一致,不再多说,有机会再单独整理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大致三个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成抽象语法树&lt;/li&gt;
&lt;li&gt;计算&lt;code&gt;followpos&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生成DFA&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原理: 重要状态&lt;/p&gt;
&lt;h3 id=&quot;以-a-b-abb-为例&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="编译原理" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="DFA" scheme="http://yoursite.com/tags/DFA/"/>
    
  </entry>
  
  <entry>
    <title>从正则到NFA到DFA[龙书]</title>
    <link href="http://yoursite.com/2018/04/21/%E4%BB%8E%E6%AD%A3%E5%88%99%E5%88%B0NFA%E5%88%B0DFA-%E9%BE%99%E4%B9%A6/"/>
    <id>http://yoursite.com/2018/04/21/从正则到NFA到DFA-龙书/</id>
    <published>2018-04-21T12:55:36.000Z</published>
    <updated>2018-04-22T12:59:07.097Z</updated>
    
    <content type="html"><![CDATA[<p>获取DFA基础步骤就三步:</p><ol><li>从正则到NFA</li><li>从NFA用子集构造法到DFA</li><li>对DFA进行最小化</li></ol><h3 id="以-a-b-abb-为例"><a href="#以-a-b-abb-为例" class="headerlink" title="以$(a|b)^{*}abb$为例"></a>以$(a|b)^{*}abb$为例</h3><h4 id="从正则到NFA"><a href="#从正则到NFA" class="headerlink" title="从正则到NFA"></a>从正则到NFA</h4><p>记住几个基础转化：</p><ol><li><p>识别$\epsilon$</p><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/epsilon.png" alt="DFA状态图"></p></li><li><p>识别$a$</p></li></ol><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/a.png" alt="DFA状态图"></p><ol><li>识别$s|t$</li></ol><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/a|b.png" alt="DFA状态图"></p><ol><li>识别$st$</li></ol><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/st.png" alt="DFA状态图"></p><ol><li>识别$s*$</li></ol><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/s*.png" alt="DFA状态图"></p><p>把正则表达式转化成语法树后对应转化成NFA即可</p><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/语法树.png" alt="DFA状态图"></p><p>(emmm…我觉得这步简单的正则就可以省略了,不复杂直接就能看出来)</p><p>然后对树自底向上转化</p><p>最底层的a, b对应</p><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/a_NFA.png" alt="DFA状态图"><img src="/2018/04/21/从正则到NFA到DFA-龙书/bNFA.png" alt="DFA状态图"></p><p>接着到了$a|b$</p><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/a|bNFA.png" alt="DFA状态图"></p><p>然后到了$(a|b)^{*}$</p><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/(a|b" alt="DFA状态图">*.png)</p><p>然后再接一个a到$(a|b)^{*}a$</p><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/半成品.png" alt="DFA状态图"></p><p>再接着向上…</p><p>最终结果是</p><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/result.png" alt="DFA状态图"></p><p>用这种转化生成的NFA与前一篇对比来看</p><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/前一篇.png" alt="DFA状态图"></p><p>区别主要在$\epsilon$上,接下来转化成DFA就会发现两者DFA结果并无差异</p><p>按照这种算法生成的NFA具有如下<strong>性质</strong>:</p><ol><li><p>N(r)的状态数最多是r中符号和算符总数的两倍</p><p>这里总共10中状态, 语法树中符号是$|,*,\&amp;$算符$a,b$共5个</p></li><li><p>N(r)只有一个接受状态且接受状态没有向外的转换</p></li><li><p>N(r)每个状态有一个用$\sum$的符号标记的指向其他节点的转换,或者最多两个指向其他节点的$\epsilon$转换</p></li></ol><h4 id="从NFA到DFA"><a href="#从NFA到DFA" class="headerlink" title="从NFA到DFA"></a>从NFA到DFA</h4><p>操作依然是使用子集构造法,跟前一篇文章方法一致</p><p>最终的DFA状态表</p><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/DFA.png" alt="DFA状态图"></p><p>画出转换图</p><p><img src="/2018/04/21/从正则到NFA到DFA-龙书/DFA图.png" alt="DFA状态图"></p><h4 id="最小化DFA"><a href="#最小化DFA" class="headerlink" title="最小化DFA"></a>最小化DFA</h4><p>方法也与前一篇一样,不再赘述</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;获取DFA基础步骤就三步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从正则到NFA&lt;/li&gt;
&lt;li&gt;从NFA用子集构造法到DFA&lt;/li&gt;
&lt;li&gt;对DFA进行最小化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;以-a-b-abb-为例&quot;&gt;&lt;a href=&quot;#以-a-b-abb-为例&quot; cl
      
    
    </summary>
    
      <category term="编译原理" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="NFA" scheme="http://yoursite.com/tags/NFA/"/>
    
      <category term="DFA" scheme="http://yoursite.com/tags/DFA/"/>
    
  </entry>
  
  <entry>
    <title>从正则到NFA到DFA到最小化</title>
    <link href="http://yoursite.com/2018/04/19/%E4%BB%8E%E6%AD%A3%E5%88%99%E5%88%B0NFA%E5%88%B0DFA%E5%88%B0%E6%9C%80%E5%B0%8F%E5%8C%96/"/>
    <id>http://yoursite.com/2018/04/19/从正则到NFA到DFA到最小化/</id>
    <published>2018-04-19T12:52:58.000Z</published>
    <updated>2018-04-26T03:02:04.652Z</updated>
    
    <content type="html"><![CDATA[<p>获取DFA基础步骤就三步:</p><ol><li>从正则到NFA</li><li>从NFA用子集构造法到DFA</li><li>对DFA进行最小化</li></ol><h3 id="构造正则表达式-ab-a-b-ba-等价的DFA"><a href="#构造正则表达式-ab-a-b-ba-等价的DFA" class="headerlink" title="构造正则表达式$(ab)^{*}(a^{*}|b^{*})(ba)^{*}$等价的DFA"></a>构造正则表达式$(ab)^{*}(a^{*}|b^{*})(ba)^{*}$等价的DFA</h3><h4 id="从正则到NFA"><a href="#从正则到NFA" class="headerlink" title="从正则到NFA"></a>从正则到NFA</h4><p>首先记住几个基本的转化:</p><p><img src="/2018/04/19/从正则到NFA到DFA到最小化/正则到NFA.png" alt="正则到NFA"></p><p>在正则表达式中只要反复使用这几个基础的转换就能获得NFA了</p><p><img src="/2018/04/19/从正则到NFA到DFA到最小化/例题1.png" alt="NFA"></p><h4 id="从NFA到DFA-子集构造法"><a href="#从NFA到DFA-子集构造法" class="headerlink" title="从NFA到DFA: 子集构造法"></a>从NFA到DFA: 子集构造法</h4><p>子集是对NFA中所有状态的子集,首先初始的一个状态子集是从开始通过任意个$\epsilon$可到达的状态集合,这里也就是$\lbrace0,1,3,4,5,6,7,9\rbrace$都是只用若干$\epsilon$就可获得的状态</p><p>接着分析每个状态的下一步, 这里只有$a,b$两个字符,对第一个子集中状态在拼接一个$a$后能到达的集合作为下一个子集,也就是$s_{0}=\lbrace2,4,6,7,9\rbrace$,注意是要包含接上一个$a$可到达的状态以及之后可以通过任意个$\epsilon$可到达的状态,详细来看$s_{1}=\lbrace\rbrace$,</p><p>0不可接a,</p><p>1可接a到达2,2后面无$\epsilon$可到状态=&gt;$s_{1}=$$\lbrace2\rbrace$</p><p>3不可接a,</p><p>4可接a到达4,4后可接$\epsilon$到6,7,9=&gt;$s_{1}=\lbrace2,4,6,7,9\rbrace$</p><p>6不可接a</p><p>7不可接a</p><p>9不可接a</p><p>结束=&gt;$s_{1}=\lbrace2,4,6,7,9\rbrace$</p><p>对b的分析也是如此,这样就获得了另一个不同的子集$s_{2}$</p><p>接着对$s_{1},s_{2}$同样分析下去,这题总共有7个不同的状态集合</p><p><img src="/2018/04/19/从正则到NFA到DFA到最小化/NFA到DFA.jpg" alt="DFA子集表"></p><p>状态表写完后,对状态子集进行标号,用$ABCD…$或者数字序号均可,就可以获得DFA的状态表了</p><p><img src="/2018/04/19/从正则到NFA到DFA到最小化/DFA.jpg" alt="DFA状态表"></p><p>根据表的指向可画出DFA转化图</p><p><img src="/2018/04/19/从正则到NFA到DFA到最小化/DFA_2.jpg" alt="DFA状态图"></p><p>注意:</p><p>图中的接受状态,所有包含NFA接受状态的子集都是DFA的接受状态,这里也就是所有包含状态9的子集都是接收状态</p><h4 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h4><p>寻找最小化的过程也就是去掉多余状态和死态</p><p>多余状态就是从这个状态无法到达接收状态</p><p>死态就是从开始无法到达的状态</p><p>这个例子中就不必最小化了,看下面的例子</p><p><img src="/2018/04/19/从正则到NFA到DFA到最小化/最小化.png" alt="最小化例题"></p><p>首先将所有的状态进行分类,第一步按照接收状态和非接受状态,分为接受状态的$s_{1}={C,D,E,F}$和非接收状态的$s_{2}=\lbrace S,A,B\rbrace$</p><p>接着对$s_{1},s_{2}$继续分类,</p><p>具体操作就是,先看$s_{1}$,其中$C,D,E,F$通过a,b之后的状态都还是在$s_{1}$中,则$CDEF$是一类,可以合并</p><p>再看$s_{2}​$,下一步接a时,$S,B​$到达A属于$s_{2}​$,A到达$C​$属于$s_{1}​$所以$s_{1}​$可以划分为$\lbrace S,B\rbrace​$和$\lbrace A\rbrace​$,再看$\lbrace S,B\rbrace​$,下一步接b时,S到B属于$s_{2}​$,B接b到D属于$s_{1}​$也就是S,B不属于一类,这样A,S,B不可合并</p><p>则最终结果是</p><p><img src="/2018/04/19/从正则到NFA到DFA到最小化/DFA最小化.jpg" alt="最小化DFA"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;获取DFA基础步骤就三步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从正则到NFA&lt;/li&gt;
&lt;li&gt;从NFA用子集构造法到DFA&lt;/li&gt;
&lt;li&gt;对DFA进行最小化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;构造正则表达式-ab-a-b-ba-等价的DFA&quot;&gt;&lt;a href=&quot;#构造正则
      
    
    </summary>
    
      <category term="编译原理" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="NFA" scheme="http://yoursite.com/tags/NFA/"/>
    
      <category term="DFA" scheme="http://yoursite.com/tags/DFA/"/>
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯</title>
    <link href="http://yoursite.com/2018/04/16/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>http://yoursite.com/2018/04/16/朴素贝叶斯/</id>
    <published>2018-04-16T08:28:13.000Z</published>
    <updated>2018-04-16T11:20:00.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="朴素贝叶斯的理论基础"><a href="#朴素贝叶斯的理论基础" class="headerlink" title="朴素贝叶斯的理论基础"></a>朴素贝叶斯的理论基础</h2><h3 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h3><p> 首先看一下概统中的条件概率,在B条件下事件A发生的概率<br>$$<br>P(A|B)=\frac{P(AB)}{P(B)}<br>$$<br>贝叶斯定理便是基于条件概率,通过$P(A|B)$求得$P(B|A)$<br>$$<br>P(B|A) =\frac{P(A|B)P(B)}{P(A)}<br>$$<br>在给定数据集$(X,Y)$中,每个样本$x$有$n$个特征$(x_{1}, x_{2}, x_{3},\cdots,x_{n})$,</p><p>标记中有$k$个类别$y=(y_{1}, y_{2},\cdots,y_{n})$.</p><p>这时给定新样本$x$,如何判断其所属的类别便是给定$x$条件下$max(P(y_{1}|x),P(y_{2}|x),cdots,P(y_{k}|x))$,</p><p>我们取概率最大的为结果标记.这时$P(y_{k}|x)$就是用贝叶斯公式:<br>$$<br>P(y_{k}|x)=\frac{P(x|y_{k})P(y_{k})}{P(x)}<br>$$<br>对公式进行一些变形和运算:</p><p>分子中的$P(y_{k})$根据数据集直接求出</p><p>$P(x|y_{k})=P(x_{1},x_{2},\cdots,x_{n}|y_{k})$,假设第$i$维的特征$x_{i}$可取的值有$S_{i}$个,类别取值个数为$k$个,那么参数个数也就是$K\prod_{i=1}^{n}S_{i}$个,这是指数级的个数,显然不行.</p><p>在这里,朴素贝叶斯算法对条件概率分布做出了独立性假设,简单的说也就是假设各个维度的特征$x_{1}, x_{2},\cdots,x_{n}$是相互独立的,此时条件概率转化为<br>$$<br>P(x|y_{k})=P(x_{1},x_{2},\cdots,x_{n}|y_{k})=\prod_{i=1}^{n}P(x_{i}|y_{k})<br>$$<br>分母部分</p><p>首先运用全概率公式:<br>$$<br>P(A) = \sum_{i=1}^{n}P(B_{i})P(A|B_{i})<br>$$<br>得到<br>$$<br>P(x)=\sum_{k}\space P(y_{k})P(x|y_{k})<br>$$<br>再运用上面的独立性假设<br>$$<br>P(x) = \sum_{k}\space P(y_{k})P(x|y_{k})=\sum_{k}P(y_{k})\prod_{i=1}^{n}P(x_{i}|y_{k})<br>$$<br>则<br>$$<br>P(y_{k}|x)=\frac{P(y_{k})\prod_{i=1}^{n}P(x_{i}|y_{k})}{\sum_{k}P(y_{k}\prod_{i=1}^{n}P(x_{i}|y_{k})}<br>$$<br>于是朴素贝叶斯分类器可表示为<br>$$<br>f(x)=argmax_{y_{k}}P(y_{k}|x)=argmax_{y_{k}}\frac{P(y_{k})\prod_{i=1}^{n}P(x_{i}|y_{k})}{\sum_{k}P(y_{k}\prod_{i=1}^{n}P(x_{i}|y_{k})}<br>$$<br>又对于所有的$y_{k}$,式中的分母都一样,则忽略分母部分,最终可表示为:<br>$$<br>f(x)=argmax_{y_{k}}P(y_{k}|x)=argmax_{y_{k}}P(y_{k})\prod_{i=1}^{n}P(x_{i}|y_{k})<br>$$<br>下面将介绍几个基本模型用来计算朴素贝叶斯</p><h2 id="几种常见模型的实现"><a href="#几种常见模型的实现" class="headerlink" title="几种常见模型的实现"></a>几种常见模型的实现</h2><h3 id="多项式模型"><a href="#多项式模型" class="headerlink" title="多项式模型"></a>多项式模型</h3><p>当特征是离散值时,使用多项式模型.</p><p>多项式模型在计算先验概率$P(y_{k})$和条件概率$P(x_{i}|y_{k})$时会做一些平滑处理,具体为:<br>$$<br>P(y_{k})=\frac{N_{y_{k}}+\alpha}{N+k\alpha}<br>$$</p><p>$$<br>P(x_{i}|y_{k})=\frac{N_{y_{k}x_{i}}+\alpha}{N_{y_{k}}+n\alpha}<br>$$</p><p>其中,</p><p>$N$是数据集的总样本数</p><p>$N_{y_{k}}$是标签为$y_{k}$的样本数,$N_{y_{k}x_{i}}$是标签为$y_{k}$中特征为$X_{i}$的样本数</p><p>$k$的标签总数, $n$是特征维度</p><p>$\alpha$是平滑系数</p><p>当$\alpha=1$时称为$Laplace$平滑,当$0&lt;\alpha&lt;1$时称$Lidstone$平滑,$\alpha=0$时不平滑</p><p>平滑处理可以避免遇到训练数据中没出现过的$x_{i}$时,$P(x_{i}|y_{k})=0$从而导致后验概率也为0.</p><h3 id="高斯模型"><a href="#高斯模型" class="headerlink" title="高斯模型"></a>高斯模型</h3><p>当特征值是连续变量时,多项式模型会当做离散值处理从而导致很多$P(x_{i}|y_{k})=0$出现(未平滑),及时进行了平滑处理,效果也不理想,这时可以采用高斯模型</p><p>高斯模型假设其中的每一维特征值都符合正太分布</p><p>比如体测信息中的身高数据,不能当做离散值计算时,我们可以宏观的看身高符合正太分布,则可以计算出身高数据的期望和方差,从而就知道了某一身高值的概率</p><p>高斯分布的概率密度函数:<br>$$<br>f(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}}<br>$$<br>高斯模型的计算:<br>$$<br>P(x_{i}|y_{k})=\frac{1}{\sigma_{y_{k},i}\sqrt{2\pi}}e^{-\frac{(x-\mu_{y_{k},i})^{2}}{2 \sigma_{y_{k},i}^{2}}}<br>$$<br>其中</p><p>$\mu_{y_{k},i}$表示标签$y_{k}$中的第$i$维特征值的期望</p><p>$\sigma_{y_{k},i}$是标签为$y_{k}$中的第$i$维特征值的标准差</p><p>也就是运用正态分布的概率密度函数,对每一组条件概率下都进行计算.</p><p>代码和对应的例子之后补更.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;朴素贝叶斯的理论基础&quot;&gt;&lt;a href=&quot;#朴素贝叶斯的理论基础&quot; class=&quot;headerlink&quot; title=&quot;朴素贝叶斯的理论基础&quot;&gt;&lt;/a&gt;朴素贝叶斯的理论基础&lt;/h2&gt;&lt;h3 id=&quot;贝叶斯定理&quot;&gt;&lt;a href=&quot;#贝叶斯定理&quot; class=&quot;he
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="朴素贝叶斯" scheme="http://yoursite.com/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
      <category term="统计学习方法" scheme="http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>概率论基础</title>
    <link href="http://yoursite.com/2018/04/14/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/04/14/概率论基础/</id>
    <published>2018-04-14T06:40:10.000Z</published>
    <updated>2018-04-14T07:57:19.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>设$P(x)$是一个离散概率分布函数, 自变量的取值范围为$[x_{1}, x_{2}, x_{3},\dots,x_{n}]$其期望定义为:<br>$$<br>E(x)=\sum_{k=1}^{n}x_{k}P(x_{k})<br>$$<br>若$P(x)$是一个连续型概率密度函数,其期望为:<br>$$<br>E(x)=\int_{-\infty}^{+\infty}xP(x)dx<br>$$</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p><strong>线性运算规则</strong>: 线性运算的期望等于期望的线性运算<br>$$<br>E(ax+by+c) = aE(x)+bE(y)+c<br>$$<br>更一般的表达形式:<br>$$<br>E(\sum_{k=1}^{n}a_{k}x_{k}+c) = \sum_{k=1}^{n}a_{k}E(x_{k}) +c<br>$$<br><strong>乘积的期望</strong></p><p>乘积的期望不等于期望的乘积,当且仅当变量相互独立时,如变量x,y相互独立,才有$E(xy)=E(x)E(y)$</p><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>方差是一种特殊的期望:<br>$$<br>Var(x) = E((x-E(x))^{2})<br>$$</p><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p><strong>另一种表示形式</strong></p><p>根据期望的性质对方差公式进行展开运算:<br>$$<br>\begin{align}<br>Var(x) &amp;= E(x^{2}-2xE(x)+(E(x))^{2}) \\<br>&amp;=E(x^{2})-2E(x)E(x)+(E(x))^{2} \\<br>&amp;=E(x^{2})-(E(x))^{2}<br>\end{align}<br>$$<br><strong>常数方差</strong></p><p>设$C$是常数,则$Var(C)=0$</p><p><strong>一些运算性质</strong></p><p>设随机变量$X$方差存在$Var(X),\space a,b$为常数则:<br>$$<br>Var(aX+b) = a^{2}Var(X)<br>$$<br>设随机变量$X,Y$方差存在,则<br>$$<br>Var(aX+bY) = a^{2}Var(X)+b^{2}Var(Y)+2Cov(X,Y)<br>$$<br>其中$Cov(X,Y)$是协方差</p><p>当变量间相互独立时,可以推广得到<br>$$<br>Var(\sum_{k=1}^{n}a_{k}X_{k}) = \sum_{k=1}^{n}a_{k}^{2}Var(X_{k})<br>$$</p><h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>$$<br>Cov(x,y) = E((x-E(x))(y-E(y)))<br>$$</p><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h4><p><strong>另一种形式</strong><br>$$<br>Cov(x,y)=E(xy)-E(x)E(y)<br>$$<br><strong>方差是一种特殊的协方差</strong><br>$$<br>Cov(x,x) = Var(x)<br>$$<br><strong>线性组合的协方差</strong><br>$$<br>Cov(\sum_{k=1}^{n}a_{k}x_{k}, \sum_{j=1}^{m}b_{j}y_{j}) = \sum_{k=1}^{n}\sum_{j=1}^{m}a_{k}b_{j}Cov(x_{k}, y_{j})<br>$$<br>一种特殊情况:<br>$$<br>Cov(a+bx, c+dy) = dbCov(x,y)<br>$$</p><h2 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h2><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>设随机变量X,Y期望和方差都存在,则X与Y的相关系数:<br>$$<br>\rho_{XY} = \frac{Cov(X,Y)}{\sqrt{Var(x)}\sqrt{Var(Y)}}<br>$$</p><h4 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h4><p><strong>有界性</strong></p><p>$|\rho_{XY}|\le1$</p><p><strong>统计意义</strong></p><p>越趋近1则说明正相关越强</p><p>越趋近-1则是负相关性越强</p><p>0是非线性相关</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;期望&quot;&gt;&lt;a href=&quot;#期望&quot; class=&quot;headerlink&quot; title=&quot;期望&quot;&gt;&lt;/a&gt;期望&lt;/h2&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;设$P
      
    
    </summary>
    
      <category term="概率统计" scheme="http://yoursite.com/categories/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="概率统计" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="相关系数" scheme="http://yoursite.com/tags/%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>决策树</title>
    <link href="http://yoursite.com/2018/03/25/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://yoursite.com/2018/03/25/决策树/</id>
    <published>2018-03-25T15:32:44.000Z</published>
    <updated>2018-03-29T13:25:31.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h2><p>分类决策树模型是一种描述对实例进行分类的属性结构.决策树由结点(node)和有向边(directed edge)组成.结点有两种类型,内部结点(internal node)和叶结点(leaf node).内部结点表示一个特征或属性,也结点表示一个类.<br>用决策树分类,从根结点开始,对实例的某一特征进行测试,根据测试结果,将实例分配到其子结点:这是,每一个子结点对应着该特征值的一个取值.如此递归的对实例进行测试并分配,直到达到叶结点.最后将实例分到叶结点的类中.</p><h2 id="特征选择-数学基础"><a href="#特征选择-数学基础" class="headerlink" title="特征选择(数学基础)"></a>特征选择(数学基础)</h2><p>特征选择在于选取对训练数据具有分类能力的特征.通常特征选择的准则是信息增益(ID3算法)或信息增益比(C4.5算法).</p><h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p>熵(entropy)表示随机变量不确定性的度量.<br>设$X$是一个取有限个值的离散变量,其概率分布为:<br>$$<br>P(X=x_{i})=p_{i}, \space i=1,2,3, \cdots, n<br>$$<br>则随机变量$X$的熵的定义为:<br>$$<br>H(X)=-\sum_{i=1}^{n}p_{i}\space log\space p_{i}<br>$$<br>若$p_{i}=0$则定义$0\space log\space0=0$<br><br>式中的对数以2为底或以$e$为底,这时结果的单位分别称作比特(bit)或者纳特(nat)<br>由定义知,熵只依赖于$X$的分布,而与$X$的取值无关,所以也可以将$X$的熵记作$H(p)$,即:<br>$$<br>H(p) = -\sum_{i=1}^{n}p_{i}\space log\space p_{i}<br>$$<br>熵越大,随机变量的不确定性越大.从定义可验证:<br>$$<br>0\leq H(p)\leq log\space n<br>$$<br>当随机变量只取两个值, 例如$1,0$时,即$X$的分布为:<br>$$<br>P(X=1) = p, \space \space P(X=0) = 1-p, \space 0\leq 1<br>$$<br>熵为:<br>$$<br>H(p) = -p\space log_2\space p-(1-p)log_{2}\space (1-p)<br>$$<br>这时熵$H(p)$随概率$p$的变化曲线如下图所示(单位为比特):</p><p><img src="/2018/03/25/决策树/H.png" alt="H(p)"></p><p>当$p=0$或$p=1$时$H(p)=0$,随机变量完全没有不确定性.当$p=0.5$时,$H(p)=1$,熵取值最大,随机变量不确定性最大.<br>简单的来说,熵就是事件发生概率的<strong>负对数的期望</strong><br>$$<br>E(X) = -\sum_{i=1}^{n}p_{i}\space log\space p_{i}<br>$$</p><h3 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h3><p>设有随机变量$(X,Y)$, 其联合概率分布为:<br>$$<br>P(X=x_{i}, Y=y_{j})=p_{ij}, \space i=1,2,\cdots\,n;\space j=1,2,\cdots,m<br>$$<br>条件熵$H(Y|X)$表示在已知随机变量$X$的条件下随机变量$Y$的不确定性,随机变量$X$给定的条件下$Y$的条件熵(conditional entropy)$H(Y|X)$,定义为$X$给定条件下$Y$的条件概率分布的熵对$X$的数学期望<br>$$<br>H(Y|X)=\sum_{i=1}^{n}p_{i}H(Y|X=x_{i})<br>$$<br>这里,$p_{i}=P(X=x_{i}), i=1,2,\cdots,n$<br>当熵和条件熵中的概率由数据估计(特别是极大似然估计)得到时,所对应的熵与条件熵分别称为经验熵(empirical entropy)和经验条件熵(empirical conditional entropy).此时,如果有0概率,令$0\space log\space0=0$</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>信息增益(information gain)表示得知特征$X$的信息而使得类$Y$的信息不确定性减少的程度.<br>特征$A$对训练数据集$D$的信息增益$g(D,A)$,定义为集合$D$的经验熵$H(D)$与特征$A$给定条件下经验条件熵$H(D|A)$之差,即<br>$$<br>g(D,A)=H(D)-H(D|A)<br>$$<br>一般地,熵$H(Y)$与条件熵$H(Y|X)$的差称为互信息(mutual information).决策树学习中的信息增益等价于训练数据集中类与特征的互信息.</p><p>决策树学习应用信息增益准则选择特征.给定训练数据集$D$和特征$A$,经验熵$H(D)$表示对数据集$D$进行分类的不确定性,而经验条件熵$H(D|A)$表示特征$A$给定条件下$D$的不确定性,那么他们的差,即信息增益就是表示由于特征$A$而使$D$的分类不确定性减少的程度.<br>根据信息增益准则的特征选择方法是:</p><p>对训练数据集$D$,计算其每个特征的信息增益,并比较他们的大小,选择信息增益最大的特征.</p><p>设训练数据集为$D$,$|D|$表示其样本容量,即样本的个数.</p><p>设有$K$个类$C_{k}, k=1,2,\cdots,K$,$|C_{k}|$是属于类$|C_{k}|$的样本个数, $\sum_{k=1}^{K}|C_{k}|=|D|$.</p><p>设特征$A$有$n$个不同取值$\lbrace a_{1},a_{2},\cdots,a_{n}\rbrace $,根据特征$A$的取值将$D$划分为$n$个子集$D_{1}, D_{2}, \cdots, D_{n}$,$|D_{i}|$为$D_{i}$样本个数,$\sum_{i=1}^{n}|D_{i}|=|D|$.</p><p>记子集$D_{i}$中属于类$C_{k}$的样本集合为$D_{ik}$,即$D_{ik}=D_{i}\cap C_{k}$</p><p>信息增益算法:</p><ol><li>计算数据集$D$的经验熵$DH(D)$<br>$$<br>H(D) = -\sum_{k=1}^{K}\frac{|C_{k}|}{|D|}log_{2}\space\frac{|C_{k}|}{|D|}<br>$$</li><li>计算特征$A$对数据集$D$的经验条件熵<br>$$<br>H(D|A)=\sum_{i=1}^{n}\frac{|D_{i}|}{|D|}H(D_{i})=-\sum_{i=1}^{n}\frac{|D_{i}|}{|D|}\sum_{i=1}^{n}\frac{|D_{ik}|}{|D_{i}|}log_{2}\space\frac{|D_{ik}|}{|D_{i}|}<br>$$</li><li>计算信息增益<br>$$<br>g(D,A) = H(D)-H(D|A)<br>$$</li></ol><p>举个例子:</p><table><thead><tr><th>ID</th><th>age</th><th>hasWork</th><th>hasOwnHouse</th><th>credit</th><th>clazz</th></tr></thead><tbody><tr><td>1</td><td>青年</td><td>否</td><td>否</td><td>一般</td><td>否</td></tr><tr><td>2</td><td>青年</td><td>否</td><td>否</td><td>好</td><td>否</td></tr><tr><td>3</td><td>青年</td><td>是</td><td>否</td><td>好</td><td>是</td></tr><tr><td>4</td><td>青年</td><td>是</td><td>是</td><td>一般</td><td>是</td></tr><tr><td>5</td><td>青年</td><td>否</td><td>否</td><td>一般</td><td>否</td></tr><tr><td>6</td><td>中年</td><td>否</td><td>否</td><td>一般</td><td>否</td></tr><tr><td>7</td><td>中年</td><td>否</td><td>否</td><td>好</td><td>否</td></tr><tr><td>8</td><td>中年</td><td>是</td><td>是</td><td>好</td><td>是</td></tr><tr><td>9</td><td>中年</td><td>否</td><td>是</td><td>非常好</td><td>是</td></tr><tr><td>10</td><td>中年</td><td>否</td><td>是</td><td>非常好</td><td>是</td></tr><tr><td>11</td><td>老年</td><td>否</td><td>是</td><td>非常好</td><td>是</td></tr><tr><td>12</td><td>老年</td><td>否</td><td>是</td><td>好</td><td>是</td></tr><tr><td>13</td><td>老年</td><td>是</td><td>否</td><td>好</td><td>是</td></tr><tr><td>14</td><td>老年</td><td>是</td><td>否</td><td>非常好</td><td>是</td></tr><tr><td>15</td><td>老年</td><td>否</td><td>否</td><td>一般</td><td>否</td></tr></tbody></table><p>根据信息增益准则选择最优特征:<br>首先看到数据最终有两类,也就是公式中$k=2$<br>先计算经验熵$H(D)$<br>$$<br>H(D) = -\frac{9}{15}log_{2}\frac{9}{15}-\frac{6}{15}log_{2}\frac{6}{15}=0.971<br>$$<br>然后计算$D$对各个特征的经验条件熵,四个特征分别记作$A_{1}, A_{2}, A_{3}, A_{4}$</p><p>可以看到$A_{1}$特征有3个,恰好是均分的,每个对应5条记录</p><p>$$<br>\begin{align}<br>g(D, A_{1}) &amp;= H(D)-\left[ \frac{5}{15}H(D_{1}) +\frac{5}{15}H(D_{2}) +\frac{5}{15}H(D_{3})\right] \\ &amp;=0.971-\left[ \frac{5}{15}\left( -\frac{2}{15}log_{2}\frac{2}{15}-\frac{3}{15}log_{2}\frac{3}{15}\right)+ \\<br>\frac{5}{15}\left( -\frac{3}{15}log_{2}\frac{3}{15}-\frac{2}{15}log_{2}\frac{2}{15}\right)+ \\<br>\frac{5}{15}\left( -\frac{4}{15}log_{2}\frac{4}{15}-\frac{1}{15}log_{2}\frac{1}{15}\right)\right] \\<br>&amp;=0.971-0.888=0.083<br>\end{align}<br>$$<br>同样的求得<br>$$<br>g(D, A_{2}) = 0.324, \space g(D, A_{3}) = 0.420,\space g(D,A_{4}) =0.363<br>$$<br>比较就可以看出$A_{3}$的信息增益最大,所以选择$A_{3}$作为最优特征</p><h3 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h3><p>以信息增益作为划分训练数据集的特征,存在偏向于选择取值较多的特征的问题.使用信息增益比(information gain ratio)可以对这一问题进行校正.</p><p>这个地方要多体会一下,具体的看,上述例子中,如果我把ID字段也作为一个特征$A_{0}$进行处理的话,毫无疑问,最优特征一定是$A_{0}$,<br>因为ID字段每一条记录都唯一,也就是说此时的条件经验熵:<br>$$<br>H(D|A_{0}) = -\sum_{i=1}^{15}log_{2}(1)=0<br>$$<br>信息增益取得最大值$H(D)$<br>这也就是说信息增益总是会倾向于取值较多的特征项,尤其是连续性特征,每一个数值都会记作唯一的,这个时候信息增益比就可以进行校正.</p><p>特征$A$对训练数据集$D$的<strong>信息增益比</strong>$g_{R}(D,A)$定义为其信息增益$g(D,A)$与训练数据集$D$关于特征$A$的值的熵$H_{A}(D)$之比.即<br>$$<br>g_{R}(D,A)=\frac{g(D,A)}{H_{A}(D)}<br>$$<br>其中<br>$$<br>H_{A}(D)=-\sum_{i=1}^{n}\frac{|D_{i}|}{|D|}log_{2}\frac{|D_{i}|}{|D|}<br>$$<br>$n$是特征A的取值个数,$D_{i}$是特征$A$取第$i$个时的样本个数</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h3><p>ID3判断的依据就是信息增益<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> pickle</span><br></pre></td></tr></table></figure></p><p>计算经验熵<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calEnt</span><span class="params">(dataframe)</span>:</span></span><br><span class="line">    classes = dataframe.groupby(by=data.columns[<span class="number">-1</span>]).size().values</span><br><span class="line">    total = classes.sum()</span><br><span class="line">    classes_pos = classes/total</span><br><span class="line">    ent = -(classes_pos * np.log2(classes_pos)).sum()</span><br><span class="line">    <span class="keyword">return</span> ent</span><br></pre></td></tr></table></figure></p><p>选择最优特征<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeat</span><span class="params">(dataframe)</span>:</span></span><br><span class="line">    total = len(dataframe)</span><br><span class="line">    Hd = calEnt(dataframe)</span><br><span class="line">    final_res = []</span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> dataframe.columns[:<span class="number">-1</span>]:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dataframe[feature].unique():</span><br><span class="line">            df = dataframe[dataframe[feature]==key]</span><br><span class="line">            result += len(df)/total * calEnt(df)</span><br><span class="line">        final_res.append([feature, total - result])</span><br><span class="line">    final_res.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> final_res[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p>判断分类结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseLabel</span><span class="params">(labels)</span>:</span></span><br><span class="line">    print(labels)</span><br><span class="line">    <span class="keyword">return</span> collections.Counter(labels).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><p>创建树,使用字典实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(df)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(df.columns)==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> chooseLabel(list(df.iloc[:,<span class="number">-1</span>]))</span><br><span class="line">    <span class="keyword">if</span> len(df.iloc[:,<span class="number">-1</span>].unique()) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> df.iloc[<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line">    bestFeature = chooseBestFeat(df)</span><br><span class="line">    Tree = &#123;bestFeature: &#123;&#125;&#125;</span><br><span class="line">    features = [i <span class="keyword">for</span> i <span class="keyword">in</span> df.columns <span class="keyword">if</span> i != bestFeature]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> df[bestFeature].unique():</span><br><span class="line">        df_ = df[df[bestFeature]==key][features]</span><br><span class="line">        Tree[bestFeature][key]=createTree(df_)</span><br><span class="line">    <span class="keyword">return</span> Tree</span><br></pre></td></tr></table></figure></p><p>分类器的实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(Tree, df)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> isinstance(Tree, dict):</span><br><span class="line">        feature = list(Tree.keys())[<span class="number">0</span>]</span><br><span class="line">        key = df[feature].values[<span class="number">0</span>]</span><br><span class="line">        Tree = Tree[feature][key]</span><br><span class="line">    <span class="keyword">return</span> Tree</span><br></pre></td></tr></table></figure></p><p>储存/读取建立好的树<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeTree</span><span class="params">(Tree, filename)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(Tree, f)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grapTree</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> pickle.load(f)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;决策树模型&quot;&gt;&lt;a href=&quot;#决策树模型&quot; class=&quot;headerlink&quot; title=&quot;决策树模型&quot;&gt;&lt;/a&gt;决策树模型&lt;/h2&gt;&lt;p&gt;分类决策树模型是一种描述对实例进行分类的属性结构.决策树由结点(node)和有向边(directed edge)组成
      
    
    </summary>
    
      <category term="统计学习方法" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>KNN与Kd-tree实现</title>
    <link href="http://yoursite.com/2018/03/21/KNN%E4%B8%8EKd-tree%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/03/21/KNN与Kd-tree实现/</id>
    <published>2018-03-21T14:09:41.000Z</published>
    <updated>2018-03-28T12:38:23.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K-近邻算法学习"><a href="#K-近邻算法学习" class="headerlink" title="K-近邻算法学习"></a>K-近邻算法学习</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述:"></a>算法描述:</h2><p>KNN原理也就是常说的物以类聚,人以群分.当无法判断当前点所属分类时,可以通过统计它所属的位置特征,衡量它周围的邻居权重,把分配到权重大的一类.</p><p>首先要知道变量之间的距离的表示:<br>$$<br>L_{p}(x_{(i)},x_{(j)})=\left( \sum_{l=1}^{n}|x_{i}^{(l)}-x_{j}^{(l)}|^{p}\right)^{\frac{1}{p}}<br>$$<br>其中p=2时就是欧氏距离<br>$$<br>L_{p}(x_{(i)},x_{(j)})=\left( \sum_{l=1}^{n}|x_{i}^{(l)}-x_{j}^{(l)}|^{2}\right)^{\frac{1}{2}}<br>$$</p><p>p=1时称曼哈顿距离:<br>$$<br>L_{p}(x_{(i)},x_{(j)})=\left( \sum_{l=1}^{n}|x_{i}^{(l)}-x_{j}^{(l)}|\right)<br>$$</p><p>p=$\propto$时, 它是各个坐标距离的最大值:<br>$$<br>L_{\propto}(x_{i}, x_{j})=max(|x_{i}^{(l)}-x_{j}^{l}|)<br>$$</p><p>KNN算法中,所选择对象的邻居对象都是已经正确分类的.该方法在定类的决策中只依据最近的一个邻居或者几个来决定所属类别.所以这里面K的取值还是很关键的.太小则容易受到训练数据的噪声影响从而产生过拟合,太大则有可能会误会测试,因为这样会使近邻中包含了远离的点.</p><p>算法描述:</p><ol><li>K(近邻数), D(训练样本集合)</li><li>z(x, y)待测样本</li><li>遍历所有样本数据,计算z到样例之间的距离d</li><li>选择最近的k个样例集合 </li></ol><h2 id="knn算法的实现"><a href="#knn算法的实现" class="headerlink" title="knn算法的实现"></a>knn算法的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knn</span><span class="params">(X_train, y_train, X_test, k)</span>:</span></span><br><span class="line">    m = len(X_test)</span><br><span class="line">    y_pre = np.empty((m,),dtype=object)</span><br><span class="line">    <span class="keyword">for</span> i, test <span class="keyword">in</span> enumerate(X_test):</span><br><span class="line">        neighbour = []</span><br><span class="line">        <span class="keyword">for</span> j, train <span class="keyword">in</span> enumerate(X_train):</span><br><span class="line">            dist = np.linalg.norm(test - train)</span><br><span class="line">            label = y_train[j]</span><br><span class="line">            neighbour.append([dist, label])</span><br><span class="line">        neighbour = np.array(neighbour)</span><br><span class="line">        k_neighbour = neighbour[neighbour[:,<span class="number">0</span>].argsort()][:k][:,<span class="number">1</span>]</span><br><span class="line">        y_pre[i] = pd.value_counts(k_neighbour).index[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> y_pre</span><br></pre></td></tr></table></figure><h2 id="简单的算法使用"><a href="#简单的算法使用" class="headerlink" title="简单的算法使用:"></a>简单的算法使用:</h2><h3 id="1-鸢尾花类别判断"><a href="#1-鸢尾花类别判断" class="headerlink" title="1. 鸢尾花类别判断"></a>1. 鸢尾花类别判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">'iris.data'</span>, header=<span class="keyword">None</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = df[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]].values</span><br><span class="line">y = df[<span class="number">4</span>].values</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.pairplot(df, hue= <span class="number">4</span>,size=<span class="number">1.2</span>,diag_kind = <span class="string">'kde'</span>,diag_kws=dict(shade=<span class="keyword">True</span>),plot_kws=dict(s=<span class="number">10</span>),)</span><br></pre></td></tr></table></figure><p><img src="/2018/03/21/KNN与Kd-tree实现/iris.png" alt="iris"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuracy_score</span><span class="params">(y_pre, y_test)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(y_pre == y_test)/ len(y_test)</span><br><span class="line"></span><br><span class="line">y_pre = knn(X_train, y_train, X_test, <span class="number">5</span>)</span><br><span class="line">accuracy_score(y_pre, y_test)</span><br></pre></td></tr></table></figure><h3 id="2-改进约会网站的匹配"><a href="#2-改进约会网站的匹配" class="headerlink" title="2. 改进约会网站的匹配"></a>2. 改进约会网站的匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">'datingTestSet.txt'</span>, sep=<span class="string">'\t'</span>, header=<span class="keyword">None</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><p>可视化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.style.use(<span class="string">'ggplot'</span>)</span><br><span class="line">g = sns.pairplot(df, hue=<span class="number">3</span>, size=<span class="number">1.2</span>,diag_kind = <span class="string">'kde'</span>,diag_kws=dict(shade=<span class="keyword">True</span>),plot_kws=dict(s=<span class="number">10</span>),)   X = df[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]].values</span><br><span class="line">y = df[<span class="number">3</span>].values</span><br></pre></td></tr></table></figure></p><p><img src="/2018/03/21/KNN与Kd-tree实现/dating.png" alt="约会网站人群"></p><p>标准化数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Normalization</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (X-X.mean(axis=<span class="number">0</span>))/X.std(axis=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">X = Normalization(X)</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line">y_pre = knn(X_train, y_train, X_test, <span class="number">5</span>)</span><br><span class="line">accuracy_score(y_pre, y_test)</span><br></pre></td></tr></table></figure></p><h3 id="3-手写字识别"><a href="#3-手写字识别" class="headerlink" title="3. 手写字识别"></a>3. 手写字识别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">train_files = os.listdir(<span class="string">'digits/trainingDigits'</span>)</span><br><span class="line">test_files = os.listdir(<span class="string">'digits/testDigits'</span>)</span><br></pre></td></tr></table></figure><p>把图像内容转换成数组形式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imgVector</span><span class="params">(files)</span>:</span></span><br><span class="line">    m = len(files)</span><br><span class="line">    X = np.empty((m, <span class="number">1024</span>), dtype=int)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    y = np.empty((m,), dtype=object)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        y[count] = file[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'digits/trainingDigits/'</span>+file) <span class="keyword">as</span> fin:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">                line = fin.readline()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">                    X[count, <span class="number">32</span>*i+j] = int(line[j])</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> X, y</span><br></pre></td></tr></table></figure></p><p>读取文件并执行knn<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X_train, y_train = imgVector(train_files) </span><br><span class="line">X_test, y_test = imgVector(test_files)</span><br><span class="line"></span><br><span class="line">y_pre = knn(X_train, y_train, X_test, <span class="number">5</span>)</span><br><span class="line">accuracy_score(y_pre, y_test)</span><br></pre></td></tr></table></figure></p><h2 id="kd树"><a href="#kd树" class="headerlink" title="kd树"></a>kd树</h2><p>上面的例子中采用的是循环遍历的方法实现了距离的计算,在数据量很大的时候这样的遍历显然会带来性能的瓶颈,当然也可以对数据进行向量化计算来提升速度,不过这里我们引入kd树这一种数据结构来存储数据并进行knn</p><p>kd树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构.kd树是二叉树,表示k维空间的一个划分(partition).构造kd树相当于不断地用垂直于坐标轴的超平面将k维空间切分,构成一系列的k维超矩形区域,kd树的每个节点对应于一个k维超矩形区域.</p><p><strong>算法: 构造平衡kd树<br></strong><br>    输入: k维空间数据集$T=\lbrace{ x_{1}, x_{2}, \dots, x_{N} \rbrace}$<br> 其中$x_{i} = \left( x_{i}^{(1)}, x_{i}^{(2)}, \dots, x_{i}^{(k)}\right), i=1, 2, \dots, N$<br><br>    输出: kd树</p><p>开始: 构造根节点, 选择$x^{(1)}$为坐标轴,以T中所有实例的$x^{(1)}$坐标的中位数为切分点,将根节点对应的超矩形区域切分成两个子区域.切分由通过切分点并与坐标轴$x^{(1)}$垂直的超平面实现</p><p>由根节点生成深度为1的左,右子结点: 左子结点对应的坐标$x^{(1)}$小于切分点的子区域,右子结点对应的坐标大于切分点的子区域</p><p>将落在切分面上的实例点保存在根节点</p><p>重复: 对于深度为$j$的结点, 选择$x^{(l)}$为切分的坐标轴<br>其中$l=(jmodK)+1$<br>以该结点的区域中所有实例的$x^{(i)}$坐标的中位数为切分点,将该结点对应的超矩形区域切分成两个子区域,切分由通过切分点并垂直于坐标轴$x^{(l)}$的超平面实现<br><br>由根节点生成深度为j+1的左,右子结点: 左子结点对应的坐标$x^{(l)}$小于切分点的子区域,右子结点对应的坐标大于切分点的子区域<br><br>将落在切分面上的实例点保存在根节点</p><p>直到两个子区域没有实例在时停止.</p><p>例:二维空间数据集:<br>$$<br>T=\lbrace{(2, 3)^{T},(5, 4)^{T},(9, 6)^{T},(4, 7)^{T},(8, 1)^{T},(7, 2)^{T}\rbrace}<br>$$</p><p>选择$x^{(1)}$轴,中位数是7,平面$x^{(1)}=7$把空间分成左右两个子矩形</p><p>左矩形中与$x^{(2)}=4$分成两个矩形,右矩形中$x^{(2)}=6$划分</p><p>重复上述操作就得到下面的示意图</p><p><img src="/2018/03/21/KNN与Kd-tree实现/kd-tree1.png" alt="划分"><br>树形结构如下:<br><br><img src="/2018/03/21/KNN与Kd-tree实现/kd-tree2.png" alt="kd-tree"></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    结点类</span></span><br><span class="line"><span class="string">    ------------</span></span><br><span class="line"><span class="string">    Parameter:</span></span><br><span class="line"><span class="string">    point: 当前节点的序列</span></span><br><span class="line"><span class="string">    split: 当前结点划分的维度</span></span><br><span class="line"><span class="string">    LL: 当前节点的左孩子</span></span><br><span class="line"><span class="string">    RR: 当前节点的右孩子</span></span><br><span class="line"><span class="string">    ------------</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, point=None, split=None, LL=None, RR=None)</span>:</span></span><br><span class="line">        self.point = point</span><br><span class="line">        self.split = split</span><br><span class="line">        self.left = LL</span><br><span class="line">        self.right = RR</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createKdTree</span><span class="params">(root, arraydata)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成KD树</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    Parameter:</span></span><br><span class="line"><span class="string">    root: 结点指针</span></span><br><span class="line"><span class="string">    arraydata: 结点所属的划分区域</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">    root: 结点</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    length = arraydata.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    dimension = arraydata.shape[<span class="number">1</span>]</span><br><span class="line">    var = np.std(arraydata, axis=<span class="number">0</span>)</span><br><span class="line">    split = np.where(var==var.max())[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    sortdata = arraydata[np.argsort(arraydata[:,split])]</span><br><span class="line">    median = sortdata.shape[<span class="number">0</span>]//<span class="number">2</span></span><br><span class="line">    point = sortdata[median]</span><br><span class="line">    root = Node(point, split)</span><br><span class="line">    root.left = createKdTree(root.left, sortdata[:median,:] )</span><br><span class="line">    root.right = createKdTree(root.right, sortdata[median+<span class="number">1</span>:,:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KNN</span><span class="params">(root, aimlst, k=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    KNN</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    Parameter:</span></span><br><span class="line"><span class="string">    root: kd-tree根节点</span></span><br><span class="line"><span class="string">    aimlst: 待分类的目标序列</span></span><br><span class="line"><span class="string">    k: 选取的近邻数</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">    node_K: 选中的k个近邻列表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    node_dist = []</span><br><span class="line">    node_k = []</span><br><span class="line">    nodelst = []</span><br><span class="line">    temp_root = root</span><br><span class="line">    <span class="keyword">while</span> temp_root:</span><br><span class="line">        nodelst.append(temp_root)</span><br><span class="line">        distance = np.linalg.norm(aimlst - temp_root.point)</span><br><span class="line">        <span class="keyword">if</span> len(node_k) &lt; k:</span><br><span class="line">            node_dist.append(distance)</span><br><span class="line">            node_k.append(temp_root.point)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_dis = np.max(node_dist)</span><br><span class="line">            <span class="keyword">if</span> distance &lt; max_dis:</span><br><span class="line">                max_index = node_dist.index(max_dis)</span><br><span class="line">                node_dist[max_index] = distance</span><br><span class="line">                node_k[max_index] = temp_root.point</span><br><span class="line">        ss = temp_root.split</span><br><span class="line">        <span class="keyword">if</span> aimlst[ss] &lt;= temp_root.point[ss]:</span><br><span class="line">            temp_root = temp_root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp_root = temp_root.right</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> nodelst:</span><br><span class="line">        back_point = nodelst.pop()</span><br><span class="line">        ss = back_point.split</span><br><span class="line">        max_dis = max(node_dist)</span><br><span class="line">        <span class="keyword">if</span> len(node_k) &lt; k <span class="keyword">or</span> abs(aimlst[ss] - back_point.point[ss])&lt; max_dis:</span><br><span class="line">            <span class="keyword">if</span> aimlst[ss] &lt;= back_point.point[ss]:</span><br><span class="line">                temp_root = back_point.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp_root = back_point.left</span><br><span class="line">            <span class="keyword">if</span> temp_root:</span><br><span class="line">                nodelst.append(temp_root)</span><br><span class="line">                cur_dist = np.linalg.norm(aimlst - temp_root.point)</span><br><span class="line">                <span class="keyword">if</span> max_dis &gt; cur_dist <span class="keyword">and</span> len(node_k) == k:</span><br><span class="line">                    max_index = node_dist.index(max_dis)</span><br><span class="line">                    node_dist[max_index] = cur_dist</span><br><span class="line">                    node_k[max_index] = temp_root.point</span><br><span class="line">                <span class="keyword">elif</span> len(node_k) &lt; k:</span><br><span class="line">                    node_dist.append(cur_dist)</span><br><span class="line">                    node_k.append(temp_root.point)</span><br><span class="line">    <span class="keyword">return</span> node_k</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单测试下</span></span><br><span class="line">df = np.array([[   <span class="number">7</span>,    <span class="number">1</span>,    <span class="number">2</span>],</span><br><span class="line">               [   <span class="number">3</span>,    <span class="number">4</span>,    <span class="number">1</span>],</span><br><span class="line">               [   <span class="number">3</span>,   <span class="number">54</span>,    <span class="number">6</span>],</span><br><span class="line">            [   <span class="number">8</span>,   <span class="number">97</span>,    <span class="number">4</span>],</span><br><span class="line">                [   <span class="number">3</span>,    <span class="number">5</span>,  <span class="number">345</span>],</span><br><span class="line">               [  <span class="number">23</span>,   <span class="number">16</span>, <span class="number">6534</span>]])</span><br><span class="line"></span><br><span class="line">root = <span class="keyword">None</span></span><br><span class="line">root = createKdTree(root, df)</span><br><span class="line"></span><br><span class="line">KNN(root, [<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>],<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这样就是选出了最近邻,在这先只写到这,代码的思想和实现已经完成,对于用于实际预测的话,可以直接使用一些库中封装好的算法,如果想自己练习的话,只要对上面代码稍作修改即可实现,大家可以自行完成,之后有时间我再来实现.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;K-近邻算法学习&quot;&gt;&lt;a href=&quot;#K-近邻算法学习&quot; class=&quot;headerlink&quot; title=&quot;K-近邻算法学习&quot;&gt;&lt;/a&gt;K-近邻算法学习&lt;/h1&gt;&lt;h2 id=&quot;算法描述&quot;&gt;&lt;a href=&quot;#算法描述&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="统计学习方法" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
